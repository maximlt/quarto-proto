[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "HoloViz is … TODO\n\n\n Back to top"
  },
  {
    "objectID": "posts/ds_release_0.13/index.html#what-is-datashader",
    "href": "posts/ds_release_0.13/index.html#what-is-datashader",
    "title": "Datashader 0.13 Release",
    "section": "What is Datashader?",
    "text": "What is Datashader?\nDatashader is an open-source Python library for rendering large datasets quickly and accurately. Datashader provides highly optimized, scalable support for rasterizing your data into a fixed-size array for pixel-based displays, while avoiding overplotting and other issues that make it difficult to work with large datasets. Datashader works well on its own, but it is even more powerful when embedded into an interactive plotting library like Bokeh, Plotly, or (now!) Matplotlib."
  },
  {
    "objectID": "posts/ds_release_0.13/index.html#announcing-datashader-0.13",
    "href": "posts/ds_release_0.13/index.html#announcing-datashader-0.13",
    "title": "Datashader 0.13 Release",
    "section": "Announcing Datashader 0.13!",
    "text": "Announcing Datashader 0.13!\nWe are very pleased to announce the 0.12.1 and 0.13 releases of Datashader! These releases include new features from a slew of different contributors, plus maintenance and bug fixes from Jim Bednar, Philipp Rudiger, Peter Roelants, Thuy Do Thi Minh, Chris Ball, and Jean-Luc Stevens.\nWhat’s new: - Matplotlib Artist for Datashader - Much more powerful categorical plotting - dynspread that actually works! - Aggregate spreading - Anti aliasing (experimental) - Datashader support in Dash - Inspect_points for interactive exploration in HoloViews"
  },
  {
    "objectID": "posts/ds_release_0.13/index.html#matplotlib-artist-for-datashader",
    "href": "posts/ds_release_0.13/index.html#matplotlib-artist-for-datashader",
    "title": "Datashader 0.13 Release",
    "section": "Matplotlib Artist for Datashader",
    "text": "Matplotlib Artist for Datashader\nThanks to Nezar Abdennur (nvictus), Trevor Manz, Thomas Caswell, and Philipp Rudiger.\nDatashader works best when embedded in an interactive plotting library so that data can be revealed at every spatial scale by zooming and panning. Thomas Caswell made a draft of Datashader support for Matplotlib during SciPy 2016 when Datashader was first announced, but there was still a lot of work needed to make it general. Various people made suggestions, but largely the sketch sat patiently waiting for someone to finish it. In the meantime, Thomas Robitaille made a simpler points-only renderer https://github.com/astrofrog/mpl-scatter-density, which is useful if that’s all that’s needed. During sprints at SciPy 2020, Nezar Abdennur and Trevor Manz rescuscitated Tom’s work, and it’s now been released at last! You can now use all the power of Datashader with any of Matplotlib’s many backends, e.g. here for the osx backend:\nimport matplotlib.pyplot as plt, dask.dataframe as dd \nimport datashader as ds, colorcet as cc \nimport datashader.transfer_functions as tf \nfrom datashader.mpl_ext import dsshow \n%matplotlib osx \n\ndf = dd.read_parquet('data/nyc_taxi_wide.parq').compute() \n\ndsshow(df, ds.Point('dropoff_x', 'dropoff_y'), norm='eq_hist', \n       cmap=cc.gray[::-1], shade_hook=tf.dynspread); \n\n\n\n\n\nSee getting_started/Interactivity to see how to use it."
  },
  {
    "objectID": "posts/ds_release_0.13/index.html#much-more-powerful-categorical-plotting",
    "href": "posts/ds_release_0.13/index.html#much-more-powerful-categorical-plotting",
    "title": "Datashader 0.13 Release",
    "section": "Much more powerful categorical plotting",
    "text": "Much more powerful categorical plotting\nThanks to Michael Ihde (@maihde), Oleg Smirnov, Philipp Rudiger, and Jim Bednar.\nOne of Datashader’s most powerful features is its categorical binning and categorical colormapping, which allow detailed understanding of how the distribution of data differs by some other variable, such as this plot of how population is segregated by race in New York City:\n\nTo build such a plot, Datashader calculates a stack of aggregate arrays simulaneously, one per category, instead of a single aggregate array as in the non-categorical case.\nPreviously, categorical binning and plotting was limited to a count() reduction, i.e., counting how many datapoints fell into each pixel, by category, implemented using a special cat_count() reduction. Categorical plotting has now been fully generalized into a new ds.by() reduction, which accepts a categorical column along with count() or any other reduction (max(), min(), mean(), sum(), etc.). Thus it’s now possible to plot the mean value of any column, per pixel, per category. See the Pipeline docs for details.\nYou can also now use categorical binning and plotting with numerical columns using new functions category_modulo and category_binning, which opens up entirely new applications for Datashader. category_binning effectively gives Datashader the power to do 3D aggregations of numeric axes, not just the usual 2D. For instance, by(category_binning('z', 0, 10, 16)) will bin by the floating-point column z, counting datapoints in each of 16 categories (0: 0&lt;=z&lt;10, 1: 10&lt;=x&lt;20, etc.). Combining category_binning with by, you can now do complex 3D binning like computing the maximum age in each (x, y, weight) range:\ncat = ds.category_binning('weight', lower=0, higher=200, nbins=10)\nagg = canvas.points(df,'x','y', agg=ds.by(cat, ds.max('age')))\ncategory_modulo is useful when working with very large numbers of unsorted integers, using a modulo operator on an integer column to reduce a large number of columns down to something more tractable for plotting.\nSee #875 and #927 for details on by, category_modulo, and category_binning (currently documented only at https://github.com/holoviz/datashader/pull/927#issuecomment-725991064)."
  },
  {
    "objectID": "posts/ds_release_0.13/index.html#dynspread-that-actually-works",
    "href": "posts/ds_release_0.13/index.html#dynspread-that-actually-works",
    "title": "Datashader 0.13 Release",
    "section": "dynspread that actually works!",
    "text": "dynspread that actually works!\nThanks to Jim Bednar.\nDatashader’s points plotting is designed to aggregate datapoints by pixel, accurately counting how many datapoints fell into each pixel. For large datasets, such a plot will accuratelyl reveal the spatial distribution of the data over the axes plotted. However, a consequence is that an individual data point not surrounded by others will show up as a single pixel, which can be difficult to see on a high-resolution monitor, and it is almost impossible to see its color. To alleviate this issue and make it easier to go back and forth between the big picture and individual datapoints, Datashader has long offered the dynspread output-transformation function, which takes each pixel and dilates it (increases it in size) until the density of such points reaches a specified metric value. However, dynspread never worked very well in practice, always either doing no spreading or one step of spreading (a 3x3 kernel). After a fresh look at the code, it became clear that the first step of spreading was artificially increasing the amount of estimated pixel density, making it very unlikely that a second or third step would ever be done.\ndynspread now spreads each pixel by an integer radius px up to the maximum radius max_px, stopping earlier if a specified fraction of data points have non-empty neighbors within the radius. This new definition provides predictable, well-behave dynspread behavior even for large values of max_px, making isolated datapoints easily visible. (#1001)\n\n\n\n\nNote that this definition is only compatible with points, as they are spatially isolated; any usage of dynspread with datatypes other than points should be replaced with spread(), which will do what was probably intended by the original dynspread call anyway (i.e., to make a line or polygon edge thicker)."
  },
  {
    "objectID": "posts/ds_release_0.13/index.html#aggregate-spreading",
    "href": "posts/ds_release_0.13/index.html#aggregate-spreading",
    "title": "Datashader 0.13 Release",
    "section": "Aggregate spreading",
    "text": "Aggregate spreading\nThanks to Jean-Luc Stevens.\nSpreading previously worked only on RGB arrays, not numerical aggregate arrays, which meant that Datashader users had to choose between seeing isolated datapoints and having interactive features like Bokeh’s hover tool and colorbars that require access to the numerical aggregate values. spread and dynspread now work equally well with either RGB aggregates or numerical aggregates, and we now recommend that users spread at the numerical aggregate level in all supported cases. E.g. in holoviews, use spread(rasterize(obj)).opts(cnorm='eq_hist', cmap='fire') (or cnorm='log') instead of datashade(obj, cmap='fire'), and you’ll now have colorbar and hover support using Bokeh 2.3.3 or later. (#771\nimport dask.dataframe as dd, holoviews as hv\nfrom holoviews.operation.datashader import rasterize, dynspread\nimport bokeh, datashader as ds\nhv.extension(\"bokeh\")\n\ndf = dd.read_parquet('data/nyc_taxi_wide.parq').compute()\npts = hv.Points(df, ['dropoff_x', 'dropoff_y'])\nopts = hv.opts.Image(cnorm='log', colorbar=True, width=700, tools=['hover'])\ndynspread(rasterize(pts)).opts(opts)"
  },
  {
    "objectID": "posts/ds_release_0.13/index.html#anti-aliasing-experimental",
    "href": "posts/ds_release_0.13/index.html#anti-aliasing-experimental",
    "title": "Datashader 0.13 Release",
    "section": "Anti-aliasing (experimental)",
    "text": "Anti-aliasing (experimental)\nThanks to Valentin Haenel.\nDatashader’s line aggregations (also used in trimesh and network plotting) count how many times a line crosses a given pixel. The resulting line plots are very blocky, because of binary transitions between rows and columns depending on where the underlying line lands in the aggregate array grid. To improve appearance of such lines (at a cost of making them less easy to interpret as counts of crossings), Datashader now supports antialiased lines. This support is only partial and is still experimental; it’s enabled by adding antialias=True to the Canvas.line() method call and is currently restricted to sum and max reductions only, and to a single-pixel line width. (#916)\n\n\nThe remaining updates listed below are shipped in other packages, not Datashader itself, but provide additional power for Datashader users."
  },
  {
    "objectID": "posts/ds_release_0.13/index.html#datashader-support-in-dash",
    "href": "posts/ds_release_0.13/index.html#datashader-support-in-dash",
    "title": "Datashader 0.13 Release",
    "section": "Datashader support in Dash",
    "text": "Datashader support in Dash\nThanks to Jon Mease.\nThe Dash package for deploying data-science dashboards now supports Datashader using the high-level HoloViews Plotly backend. HoloViews Plotly, Matplotlib, and Bokeh plots can now be deployed using either a Bokeh-based server, which supports user-specific state that makes programmimg simpler, or a Dash-based server, which has a stateless model that can support larger numbers of concurrent users on a given set of server hardware."
  },
  {
    "objectID": "posts/ds_release_0.13/index.html#inspect-function-for-interactive-exploration-in-holoviews",
    "href": "posts/ds_release_0.13/index.html#inspect-function-for-interactive-exploration-in-holoviews",
    "title": "Datashader 0.13 Release",
    "section": "inspect function for interactive exploration in HoloViews",
    "text": "inspect function for interactive exploration in HoloViews\nThanks to Jean-Luc Stevens and Philipp Rudiger.\nHoloViews has always been an easy way to work with interactive Datashader plots by handling user events, requesting an updated Datashader plot, and rendering the results. However, the resulting plots always showed only an aggregated view of the data, no matter how much the user zoomed in. HoloViews 1.14.4 now ships with inspect_points() and inspect_polygons wrapped in a general inspect function that uses Datashader’s aggregate to determine if there is data in a local region, then queries the original dataset to return those specific points and all their metadata. The result is that you can now view all of your data using Datashader, while still being able to see individual data points using hover or selection.\nSee the new ship_traffic example for how to use inspect_points and the NYC Buildings example for how to use inspect_polygons. Also see HoloViews linked brushing for related functionality that supports linked selections on Datashader and other plots."
  },
  {
    "objectID": "posts/ds_release_0.13/index.html#help-us",
    "href": "posts/ds_release_0.13/index.html#help-us",
    "title": "Datashader 0.13 Release",
    "section": "Help us!",
    "text": "Help us!\nDatashader is an open-source project and we are always looking for new contributors. Join us the discussion on the Discourse and we would be very excited to get you started contributing! Also please get in touch with us if you work at an organization that would like to support future Datashader development, fund new Datashader features, or set up a support contract."
  },
  {
    "objectID": "posts/panel_release_0.10/index.html",
    "href": "posts/panel_release_0.10/index.html",
    "title": "Panel 0.10.0 Release",
    "section": "",
    "text": "What is Panel?\nPanel is an open-source library that lets you create custom interactive web apps and dashboards by connecting widgets to plots, images, tables, and text - all while writing only Python!\nPanel integrates seamlessly with your existing work:\nPlease check out the Panel website to find out more.\nNew release!\nWe are very pleased to announce the 0.10 release of Panel! This release focuses on adding a number of powerful features requested by our users, including:\nMany, many thanks to the people who contributed to this release, including @philippjfr (author, maintainer, release manager), @MarkSkovMadsen (alert pane, templates, docs), @xavArtley (VTK improvements, templates, input/spinner widgets), @maximlt (panel serve), @jbednar (docs, reviewing), @kebowen (templates), @ahuang11 (datepicker), @nghenzi (react template, bugfixes), @nritsche (panel serve), @ltalirz (autocomplete input), @BoBednar (docs), @tmikolajczyk, @halilbay, @Hoxbro, and @ceball (testing and automation).\nIf you are using Anaconda, you can get the latest Panel with conda install -c pyviz panel , and using pip you can install it with pip install panel."
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#templates-and-themes",
    "href": "posts/panel_release_0.10/index.html#templates-and-themes",
    "title": "Panel 0.10.0 Release",
    "section": "Templates and Themes",
    "text": "Templates and Themes\nPanel has always made it easy to build simple applications quickly and allowed more advanced users to use the Jinja templating system to build more polished dashboards. However in many applications and for many users, building such a custom template added a lot of complexity. This release therefore adds a number of predefined BasicTemplate classes, which are in fact anything but basic. They allow users to easily populate a clean dashboard and build on a number of popular CSS frameworks, straight out of the box. Users can currently choose from:\n\nReactTemplate: Builds on the react-grid-layout framework, making it easy to build responsive, resizable and draggable grid layouts.\n\n\n\n\n\nMaterialTemplate: Builds on the Material UI framework using material-components-web\n\n\n\n\n\nGoldenTemplate: Builds on Golden Layout with the ability to resize individual tabs\n\n\n\n\n\nBootstrapTemplate: Builds on the Bootstrap framework.\n\n\n\nVanillaTemplate: Builds on pure CSS and JS without any external CSS framework."
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#card-and-accordion-layouts",
    "href": "posts/panel_release_0.10/index.html#card-and-accordion-layouts",
    "title": "Panel 0.10.0 Release",
    "section": "Card and Accordion layouts",
    "text": "Card and Accordion layouts\nThe set of standard layout types that are available also expanded this release to include Card and Accordion layouts, which can be incredibly useful when you do not want all the content visible by default.\n\nw1 = pn.widgets.TextInput(name='Text:')\nw2 = pn.widgets.FloatSlider(name='Slider')\n\ncard = pn.Card(w1, w2, title='Card', background='WhiteSmoke')\ncard\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nClicking on the +/- button will expand and collapse the card. Similarly the Accordion allows stacking multiple cards on top of each other, providing a compact way to lay out multiple components. If toggle=True is set, only one of the cards will be expanded at a time, ensuring a consistently compact layout.\n\nfrom bokeh.plotting import figure\n\np1 = figure(width=300, height=300, name='Scatter', margin=5)\np1.scatter([0, 1, 2, 3, 4, 5, 6], [0, 1, 2, 3, 2, 1, 0])\n\np2 = figure(width=300, height=300, name='Line', margin=5)\np2.line([0, 1, 2, 3, 4, 5, 6], [0, 1, 2, 3, 2, 1, 0])\n\naccordion = pn.Accordion(('Scatter', p1), p2, toggle=True)\naccordion"
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#ipywidgets-support",
    "href": "posts/panel_release_0.10/index.html#ipywidgets-support",
    "title": "Panel 0.10.0 Release",
    "section": "ipywidgets support",
    "text": "ipywidgets support\nThe Bokeh and ipywidgets ecosystems are both thriving but until recently they have not played very well together. Since version 0.7, Panel has supported rendering as an ipywidget, so that Panel components can be used in a library like Voilà:\n\nimport ipywidgets as ipw\nfrom ipyleaflet import Map, VideoOverlay\n\nslider = pn.widgets.IntSlider()\n\npn.Row(\n    ipw.VBox([ipw.Label('This is a Bokeh/Panel widget inside an ipywidgets layout:'), pn.ipywidget(slider)]),\n    height=100\n)\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nIn this release we have also added support for using ipywidgets directly inside your Panel app and even deploying it on the (Bokeh-based) Panel server. Just install ipywidgets_bokeh with conda install -c bokeh ipywidget_bokeh or using pip with pip install ipywidgets_bokeh.\n\nm = Map(center=(25, -115), zoom=4)\n\nvideo = VideoOverlay(\n    url=\"https://www.mapbox.com/bites/00188/patricia_nasa.webm\",\n    bounds=((13, -130), (32, -100))\n)\n\nm.add_layer(video);\n\npn.Column(\n    '# ipyleaflet in Panel', m,\n    sizing_mode='stretch_width'\n)\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nSee more examples on how to leverage the IPyWidget in Panel see the reference examples."
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#busy-indicators",
    "href": "posts/panel_release_0.10/index.html#busy-indicators",
    "title": "Panel 0.10.0 Release",
    "section": "Busy indicators",
    "text": "Busy indicators\nWhen working with long running computations you often want to give your users an indication that the application is loading or processing. In the past, users had to use custom GIFs to indicate a busy status. This release introduces a growing set of BusyIndicators that allow signalling a busy status visually.\nCurrently, BooleanStatus and LoadingSpinner types are available. The former simply displays a filled circle to indicate when the app is busy and an empty circle when it is not, while the latter spins to indicate the busy status:\n\nfrom panel.widgets.indicators import BooleanStatus, LoadingSpinner\n\npn.Column(\n    pn.Row(\n        *(BooleanStatus(value=True, width=50, height=50, color=color)\n        for color in LoadingSpinner.param.color.objects)\n    ),\n    pn.Row(\n        *(LoadingSpinner(value=True, width=50, height=50, color=color)\n        for color in LoadingSpinner.param.color.objects)\n    ),\n)\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nThis release also adds the pn.state.sync_busy method, which links the indicators to a global busy state. Now, whenever the application is busy processing a request, an indicator can automatically display this state:\nspinner = LoadingSpinner()\npn.state.sync_busy(spinner)\nThis method makes it very straightforward to include such an indicator in your application. As a bonus, the templates mentioned above automatically add such an indicator to the header, so you don’t need to do anything at all to have a busy indicator if you use one of the templates."
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#echarts",
    "href": "posts/panel_release_0.10/index.html#echarts",
    "title": "Panel 0.10.0 Release",
    "section": "ECharts",
    "text": "ECharts\nThe ECharts library supports a wide range of plot types and makes it easy to generate polished plots with animated transitions. Panel now supports rendering ECharts from a simple JSON-style specification:\n\nechart = {\n    'title': {\n        'text': 'ECharts entry example'\n    },\n    'tooltip': {},\n    'legend': {\n        'data':['Sales']\n    },\n    'xAxis': {\n        'data': [\"shirt\",\"cardign\",\"chiffon shirt\",\"pants\",\"heels\",\"socks\"]\n    },\n    'yAxis': {},\n    'series': [{\n        'name': 'Sales',\n        'type': 'bar',\n        'data': [5, 20, 36, 10, 10, 20]\n    }],\n};\n\nplot_type = pn.widgets.Select(name=\"Plot type\", options=['bar', 'line', 'scatter'], value='bar')\n\nechart_pane = pn.pane.ECharts(echart, height=480, width=640)\n\nplot_type.jscallback(args={'echart': echart_pane}, value=\"\"\"\nechart.data.series[0].type = cb_obj.value\nechart.properties.data.change.emit()\n\"\"\")\n\npn.Column(plot_type, echart_pane)"
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#indicators",
    "href": "posts/panel_release_0.10/index.html#indicators",
    "title": "Panel 0.10.0 Release",
    "section": "Indicators",
    "text": "Indicators\nThis release also includes a number of ValueIndicator types, similar to the BooleanIndicator components we discussed above. A ValueIndicator provides a quick way to visualize a scalar, numeric value, which comes in very useful for building BI dashboards.\n\nDial\n\ndial = pn.indicators.Dial(\n    name='Failure Rate', value=72, format='{value}%', bounds=(0, 100),\n    colors=[(0.33, 'green'), (0.66, 'gold'), (1, 'red')]\n)\n\npn.Row(dial.clone(value=10), dial.clone(value=42), dial.clone(value=93))\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\nGauge\n\ngauge = pn.indicators.Gauge(\n    name='Failure Rate', value=72, format='{value}%',\n    colors=[(.33, 'green'), (.66, 'gold'), (1, 'red')]\n)\n\npn.Row(gauge.clone(value=10), gauge.clone(value=42), gauge.clone(value=93))\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\nNumber\n\nnumber = pn.indicators.Number(\n    name='Failure Rate', value=72, format='{value}%',\n    colors=[(33, 'green'), (66, 'gold'), (100, 'red')]\n)\n\npn.Row(number.clone(value=10), number.clone(value=42), number.clone(value=93))"
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#deferred-loading",
    "href": "posts/panel_release_0.10/index.html#deferred-loading",
    "title": "Panel 0.10.0 Release",
    "section": "Deferred loading",
    "text": "Deferred loading\nAnother useful bit of functionality for making apps feel more responsive, particularly during initial rendering, is the new pn.state.onload method, which allows scheduling a task once the page is rendered. In this way developers can defer long running computations until after the initial app is rendered, so that the user actually sees something on screen from the start. As a simple example, you might have a Column with a message indicating that the app is still loading, which is then replaced with the real contents once the application is rendered:\nstocks_url = 'https://raw.githubusercontent.com/vega/datalib/master/test/data/stocks.csv'\n\nselect_ticker = pn.widgets.Select(name='Stock Ticker')\n\ndef load_data():\n    pn.state.cache['stocks'] = df = pd.read_csv(stocks_url, parse_dates=['date']).set_index('symbol')\n    symbols = list(df.index.unique())\n    select_ticker.options = symbols\n    select_ticker.value = symbols[0]\n\npn.state.onload(load_data)\n\n@pn.depends(select_ticker)\ndef plot_ticker(ticker):\n    if 'stocks' not in pn.state.cache or ticker:\n        return pn.indicators.LoadingSpinner(value=True)\n    return pn.state.cache['stocks'].loc[ticker].hvplot.line('date', 'price')\n\npn.Row(select_ticker, plot_ticker).servable()"
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#authenticated-apps",
    "href": "posts/panel_release_0.10/index.html#authenticated-apps",
    "title": "Panel 0.10.0 Release",
    "section": "Authenticated Apps",
    "text": "Authenticated Apps\nAnother common problem users face when publishing an application is to add some form of authentication in front of it, whether to limit the users that can view the app, provide customized content in the app, or simply to keep track of the users who log in. This release ships with a number of OAuth providers, which make it extremely easy to put an authenticated login page in front of your app. After registering an application with one of the currently supported identity providers:\n\nazure: Azure Active Directory\nbitbucket: Bitbucket\ngithub: GitHub\ngitlab: GitLab\ngoogle: Google\nokta: Okta\n\nyou can pass in the OAuth configuration as CLI options to panel serve, via environment variables, or you can configure it directly on pn.config. Once configured, the user will be prompted to log in when visiting the app and the information in the returned token will be available from the pn.state.user and pn.state.user_info objects. Read more about authentication in our user guide."
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#read-and-write-the-url",
    "href": "posts/panel_release_0.10/index.html#read-and-write-the-url",
    "title": "Panel 0.10.0 Release",
    "section": "Read and write the URL",
    "text": "Read and write the URL\nBeing able to manipulate the URL bar directly from Python makes a wide range of functionality possible in your apps. The new Location component which mirrors the Javascript window.location object makes this possible and can be accessed from pn.state.location in a Panel application. Not only can you now forward the user to a new location by updating the url, but you can sync the query parameters with some state in your application, letting your users share links to the application that persist some of the state. That way users can configure your app for their usage, then save or send a URL that lets the same state be restored when the URL is visited.\nYou can manipulate the parameters on the Location component directly, which will then be reflected in the URL bar in the browser:\n\npn.state.location\n\nLocation(hash='', hostname='', href='', name='Location01452', pathname='', port='', protocol='', reload=False, search='')\n\n\nOr use the update_query method to easily update the URL by passing explicit keywords:\npn.state.location.update_query(a=1, b=3)\nThe URL will now reflect these parameters:\nhttp://localhost:5006/app?a=1&b3\nYou can even link the location state automatically with a parameter, e.g. a widget value, which means that on load the widget will reflect the URL parameter and subsequently automatically updates the URL with the current widget value so that the state can be restored when the URL is visited:\nwidget = pn.widgets.FloatSlider(name='FloatSlider')\npn.state.location.sync(widget, {'value': 'slider_value'})\nThe URL query parameters will now automatically update to reflect the current slider value:\nhttp://localhost:5006/app?slider_value=0"
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#serving-static-assets",
    "href": "posts/panel_release_0.10/index.html#serving-static-assets",
    "title": "Panel 0.10.0 Release",
    "section": "Serving static assets",
    "text": "Serving static assets\nAnother feature users have frequently requested is the ability to publish additional static resources (data files, images, or other media or downloadable objects) alongside the apps and dashboards. This release provides the ability to easily specify static directories to serve, both on the commandline:\npanel serve some_script.py --static-dirs assets=./assets\nand programmatically:\npn.serve(panel_obj, static_dirs={'assets': './assets'})\nIn both cases the ./assets folder will be served alongside the dashboard at the /assets endpoint."
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#rest-apis",
    "href": "posts/panel_release_0.10/index.html#rest-apis",
    "title": "Panel 0.10.0 Release",
    "section": "REST APIs",
    "text": "REST APIs\nIn addition to serving static assets, you may also want to publish a live REST API alongside your app, to allow automated querying of the state of the app or some data from it. Panel now ships with an extensible set of REST providers that make it trivial to serve up some data or other info with your app. By default Panel ships with two REST providers:\n\nParam REST Provider\nThe Param REST provider is an easy entry point to publishing data with Panel. Using the pn.state.publish method you can set up an endpoint to publish the parameters of any Parameterized object. As a very simple example, if you serve the following application with panel serve app.py --rest-provider param:\nimport panel as pn\n\nslider = pn.widgets.FloatSlider()\npn.state.publish('slider', slider, ['value'])\n\nslider.servable()\nYou will be able to visit: http://localhost:5006/rest/freq, which will return the current slider value:\n{\"value\": 0}\nThis of course works not only for widgets and other panel components, but any Parameterized class, as long as the parameters are JSON serializable.\n\n\nTranquilizer REST Provider\nThe Param provider makes it easy to publish parameter values as-is, while the new Tranquilizer provider makes it easy to publish functions that compute results before returning them. Below we declare a select widget that we sync with the global cache. In the tranquilized order function, we then return a string whose contents depend on the most recently selected order:\nimport panel as pn\n\nfrom tranquilizer import tranquilize\n\nselect = pn.widgets.Select(options=['Cheddar', 'Mozarella', 'Parmeggiano'], value='Cheddar')\n\ndef update_cache(event):\n    pn.state.cache['cheese'] = event.new\n\nselect.param.watch(update_cache, 'value')\n\n@tranquilize()\ndef order():\n    '''I'd like to buy some cheese!'''\n    return f\"I'm afraid we're fresh out of {pn.state.cache['cheese'].lower()}, sir.\"\n\nselect.servable()\nNow when we serve this app with panel serve app.py --rest-provider tranquilizer, visit http://localhost:5006, select a cheese, and hit http://localhost:5006/rest/order we get back:\n\"I'm afraid we're fresh out of mozarella, sir.\"\nBoth of these providers make it very easy to set up a REST endpoint, and other providers can easily be registered."
  },
  {
    "objectID": "posts/panel_release_0.10/index.html#roadmap",
    "href": "posts/panel_release_0.10/index.html#roadmap",
    "title": "Panel 0.10.0 Release",
    "section": "Roadmap",
    "text": "Roadmap\nThis release has included a ton of great features and we have many more features planned. Some highlights include:\n\nPolishing templates and themes\nThis release brought the addition of a number of templates and accompanying themes. While we spent a lot of time making sure these would be general there are many improvements and tweaks that we want to make based on user feedback, so please let us know if you find issues.\n\n\nCustom components\nWe want to provide expert users with the power to develop their own HTML objects (including custom WebComponents), then have them appear as Panel components synchronized bi-directionally with the HTML state. To allow this we are working on an API to connect attributes and properties on HTML elements into Python objects, allowing custom components (e.g. new widget types) to be used within Panel just like existing widgets and panes are.\n\n\nTemplated layouts\nComplementing the ability to define individual custom components, we want to allow users to declare custom layouts by writing small HTML template strings the components will be inserted into. This will make it possible to leverage custom CSS or JS frameworks, e.g. to build custom types of responsive grids that can be used just like the current Panel layouts (Row, Column, etc.).\n\n\nResponsive grids\nIn addition to allowing users to build custom layouts using their favorite CSS/JS frameworks, we also want to ship a well-suported responsive grid layout that reflows components on the page based on the size of the browser tab. Reflowing will make it much easier to provide a great experience on mobile devices.\n\n\nBetter debugging and profiling\nWe also want to make the process of desiging, building, debugging, and optimizing apps easier. We plan to develop new tools to visualize Panel and Param callback and dependency graphs, to help developers understand how data and events propagate through their panels. To help them identify performance bottlenecks, these graphs will be annotated with timing information so that the slow steps can easily be identified.\n\n\nDocumentation overhaul\nAs we approach a Panel 1.0 release we want to overhaul the documentation so it becomes much easier to find the information you are looking for.\n\n\nHelp us!\nPanel is an open-source project and we are always looking for new contributors. Join us the discussion on the Discourse and we would be very excited to get you started contributing! Also please get in touch with us if you work at an organization that would like to support future Panel development, fund new Panel features, or set up a support contract.\n\n\nSponsors\nMany thanks to our existing sponsors:"
  },
  {
    "objectID": "posts/hv_release_1.10/index.html",
    "href": "posts/hv_release_1.10/index.html",
    "title": "HoloViews 1.10 Release",
    "section": "",
    "text": "We are very pleased to announce the release of HoloViews 1.10!\nThis release contains a large number of features and improvements. Some highlights include:\nJupyterLab support:\nNew components:\nPlus many other bug fixes, enhancements and documentation improvements. For full details, see the Release Notes.\nIf you are using Anaconda, HoloViews can most easily be installed by executing the command conda install -c pyviz holoviews . Otherwise, use pip install holoviews."
  },
  {
    "objectID": "posts/hv_release_1.10/index.html#jupyterlab-support",
    "href": "posts/hv_release_1.10/index.html#jupyterlab-support",
    "title": "HoloViews 1.10 Release",
    "section": "JupyterLab support",
    "text": "JupyterLab support\nWith JupyterLab now coming out of the alpha release stage, we have finally made HoloViews compatible with JupyterLab by creating the jupyterlab_pyviz extension. The extension can be installed with:\njupyter labextension install @pyviz/jupyterlab_pyviz\n\nThe JupyterLab extension provides all the interactivity of the classic notebook, and so both interfaces are now fully supported. Both classic notebook and JupyterLab now make it easier to work with streaming plots, because deleting or re-executing a cell in the classic notebook or JupyterLab now cleans up the plot and ensures that any streams are unsubscribed."
  },
  {
    "objectID": "posts/hv_release_1.10/index.html#new-elements",
    "href": "posts/hv_release_1.10/index.html#new-elements",
    "title": "HoloViews 1.10 Release",
    "section": "New elements",
    "text": "New elements\nThe main improvement in this release is the addition of a large number of elements. A number of these elements build on the Graph element introduced earlier in the 1.9 release, including the Sankey, Chord and TriMesh elements. Other new elements include HexTiles for binning many points on a hexagonal grid, Violins for comparing distributions across multiple variables, Labels for plotting large collections of text labels, and Div for displaying arbitrary HTML alongside Bokeh-based plots and tables.\n\nSankey\nThe new Sankey element is a pure-Python port of d3-sankey. Like most other elements, it can be rendered using both Matplotlib and Bokeh. In Bokeh, all the usual interactivity will be supported, such as providing hover information and interactively highlighting connected nodes and edges. Here we have rendered energy flow to SVG with matplotlib:\n\n\n\nChord\nThe Chord element had been requested a number of times, because it had previously been supported in the now deprecated Bokeh Charts package. Thanks to Bokeh’s graph support, hovering and tapping on the Chord nodes highlights connected nodes, helping you make sense of even densely interconnected graphs:\n\n\n&lt;div class=\"bk-plotdiv\" id=\"9fbcf76b-0d81-488f-839a-5168da791328\"&gt;&lt;/div&gt;\n\n\n\n\n\nTriMesh\nAlso building on the graph capabilities is the TriMesh element, which allows defining arbitrary meshes from a set of nodes and a set of simplices (triangles defined as lists of node indexes). The TriMesh element allows easily visualizing Delaunay triangulations and even very large meshes, thanks to corresponding support added to datashader. Below we can see an example of a TriMesh colored by vertex value and an interpolated datashaded mesh of the Chesapeake Bay containing 1M triangles:\n\n\n&lt;div class=\"bk-root\"&gt;\n  &lt;div class=\"bk-plotdiv\" id=\"02449e62-fec2-4f94-b569-a859f56ecec1\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n\n\n\n\nHexTiles\nAnother often requested feature is the addition of a hexagonal bin plot, which can be very helpful in visualizing large collections of points. Thanks to the recent addition of a hex tiling glyph in the bokeh 0.12.15 release it was straightforward to add this support in the form of a [HexTiles element]((http://holoviews.org/reference/elements/bokeh/HexTiles.html), which supports both simple bin counts and weighted binning, and fixed or variable hex sizes.\nBelow we can see a HexTiles plot of ~7 million points representing the NYC population, where each hexagonal bin is scaled and colored by the bin value:\n\n\n&lt;div class=\"bk-plotdiv\" id=\"f8bd495f-f86e-4b08-b707-b498a03050d6\"&gt;&lt;/div&gt;\n\n\n\n\n\nViolin\nViolin elements have been one of the most frequently requested plot types since the Matplotlib-only Seaborn interface was deprecated from HoloViews. With this release a native implementation of violins was added for both Matplotlib and Bokeh, which allows comparing distributions across one or more independent variables:\n\n\n\nRadial HeatMap\nThanks to the contributions of Franz Woellert, the existing HeatMap element has now gained support for radial heatmaps. Radial heatmaps are useful for plotting quantities varying over some cyclic variable, such as the day of the week or time of day. Below we can see how the daily number of Taxi rides changes over the course of a year:\n\n\n\nLabels\nThe existing Text element allows adding text to a plot, but only one item at a time, which is not suitable for plotting the large collections of text items that many users have been requesting. The new Labels element provides vectorized text plotting, which is probably most often used to annotate data points or regions of another plot type. Here we show that it can also be used on its own, to plot unicode emoji characters arranged by semantic similarity using the t-SNE dimensionality reduction algorithm:\n\n\n\nDiv\nThe Div element is exclusive to Bokeh and allows embedding arbitrary HTML in a Bokeh plot. One simple example of the infinite variety of possible uses for Div is to display Pandas summary tables alongside a plot:\n\nbars + hv.Div(df.describe().to_html())"
  },
  {
    "objectID": "posts/hv_release_1.10/index.html#editing-tools",
    "href": "posts/hv_release_1.10/index.html#editing-tools",
    "title": "HoloViews 1.10 Release",
    "section": "Editing Tools",
    "text": "Editing Tools\nIn the Bokeh 0.12.15 release, a new set of interactive tools were added to edit and draw different glyph types. These tools are now available from HoloViews as the PointDraw, PolyDraw, BoxEdit, and PolyEdit streams classes, which make the drawn or edited data available to work with from Python. The drawing tools open up the possibility for very complex interactivity and annotations, allowing users to create even very complex types of interactive applications.\n\n   \n\nOne example of the many workflows now supported is to draw regions of interest on an image using BoxEdit, computing the mean value over time for each such region:"
  },
  {
    "objectID": "posts/hv_release_1.10/index.html#setting-options",
    "href": "posts/hv_release_1.10/index.html#setting-options",
    "title": "HoloViews 1.10 Release",
    "section": "Setting options",
    "text": "Setting options\nThe new .options() method present on all viewable objects makes it much simpler to set options without worrying about the underlying difference between plot, style, and norm options. A comparison between the two APIs demonstrates how much more readable and easy to type the new approach is:\n\n# New options API\nimg.options(cmap='RdBu_r', colorbar=True, width=360, height=300)\n\n# Old opts API\nimg.opts(plot=dict(colorbar=True, width=360), style=dict(cmap='RdBu_r'));\n\nEach option still belongs to one of the three categories internally, depending on whether it is processed by HoloViews or passed down into the underlying plotting library, but the user no longer usually has to remember which options are in which category.\nIt is also now possible to explicitly declare the backend for each option, which makes it easier to support multiple backends:\n\nimg.options(width=360, backend='bokeh').options(fig_inches=(6, 6), backend='matplotlib');"
  },
  {
    "objectID": "posts/hv_release_1.10/index.html#image-hover",
    "href": "posts/hv_release_1.10/index.html#image-hover",
    "title": "HoloViews 1.10 Release",
    "section": "Image hover",
    "text": "Image hover\nThanks to coming changes in bokeh 0.12.16, HoloViews will finally support hovering over images to reveal the underlying values, e.g. here we can see the NYC census data this time aggregated using datashader:\n\n\n&lt;div class=\"bk-plotdiv\" id=\"635df30e-1b6b-45b7-8626-f5f074c18895\"&gt;&lt;/div&gt;"
  },
  {
    "objectID": "posts/hv_release_1.10/index.html#data-interfaces",
    "href": "posts/hv_release_1.10/index.html#data-interfaces",
    "title": "HoloViews 1.10 Release",
    "section": "Data interfaces",
    "text": "Data interfaces\nThe data interfaces that underlie HoloViews’ ability to work natively with a variety of data structures also saw further improvements.\n\nBinned and irregular data\nIt is now possible to declare binned data and irregular data, which has allowed Histogram and QuadMesh to finally support data interfaces. With this change, all Element types are now Dataset classes, with uniform architectures and supported usages.\n\n## Binned data\nn = 20\nx = np.arange(n+1)         # Linear bins\ny = np.logspace(0, 2, n+1) # Log bins\nz = x*x[np.newaxis].T\n\n# Irregular data\ncoords = np.linspace(-1.5, 1.5, n)\nX,Y = np.meshgrid(coords, coords)\n\nQx = np.cos(Y) - np.cos(X) # 2D coordinate array\nQz = np.sin(Y) + np.sin(X) # 2D coordinate array\nZ = np.sqrt(X**2 + Y**2)\n\nhv.Histogram((x, y)) + hv.QuadMesh((y, x, z)) + hv.QuadMesh((Qx, Qz, Z))\n\n\n\n\n\n\n\nDask arrays\nHoloViews previously supported Dask arrays via XArray, but Dask arrays are now also supported directly, allowing operations on large datasets to be performed out-of-core simply by annotating the data with coordinates:\n\nimport dask.array as da\n\nn = 100\ndask_array = da.from_array(np.random.rand(n, n), chunks=10)\nhv.Image((range(n), range(n), dask_array))"
  },
  {
    "objectID": "posts/hv_release_1.10/index.html#documentation-other-improvements",
    "href": "posts/hv_release_1.10/index.html#documentation-other-improvements",
    "title": "HoloViews 1.10 Release",
    "section": "Documentation & other improvements",
    "text": "Documentation & other improvements\nA new Colormap user guide provides an overview of the available colormaps and how to effectively choose a colormap to reveal your data. It also introduces the new hv.plotting.list_cmaps function, which makes it easy to query for a list of colormaps satisfying certain criteria (e.g. when providing a choice of appropriate colormaps to a user). For example, here is the output of hv.plotting.list_cmaps(category='Diverging', bg='light', reverse=False) when applied to an image, giving you a large number of alternatives that are all appropriate for this particular type of data:\n\nAn additional new Styling plots user guide provides an in-depth overview of how to control colors, cycles, palettes and cmaps, which are now consistently handled across backends and support new features such as discrete color_levels and symmetric color ranges:\n\nimg.options(color_levels=5, symmetric=True) + img.options(color_levels=11, symmetric=True)\n\n\n\n&lt;div class=\"bk-plotdiv\" id=\"e6c241c1-ab16-4748-b94d-44b5330dba60\"&gt;&lt;/div&gt;"
  },
  {
    "objectID": "posts/panel_release_0.13/index.html",
    "href": "posts/panel_release_0.13/index.html",
    "title": "Panel 0.13.0 Release",
    "section": "",
    "text": "What is Panel?\nPanel is an open-source library that lets you create custom interactive web apps and dashboards by connecting widgets to plots, images, tables, and text - all while writing only Python!\nPanel integrates seamlessly with your existing work:\nPlease check out the Panel website to find out more.\nNew release!\nWe are very pleased to announce the 0.13 release of Panel! This release focuses on adding a number of powerful features requested by our users, including:\nHowever, as Panel is moving towards a 1.0 release the large number of bug fixes are almost of equal importance. For a full overview of the changes in this release view the release notes.\nMany, many thanks to everyone who filed issues or contributed to this release. In particular we would like to thank @nghenzi, @Stubatiger, @hyamanieu, @samuelyeewl, @ARTUSI, @pmav99, @Prashant0kgp, @L8Y, @ingebert, @rahulporuri, @lemieux, @blelem, @raybellwaves, @sdc50, @sophiamyang, @gnowland, @govinda18, @maartenbreddels, @andriyor, @j-r77, @robmarkcole, @douglas-raillard-arm, @Kadek, @joelostblom for contributing various fixes and improvements. Special thanks for the growing list of core contributors and maintainers including @jbednar, @xavArtley, @Hoxbro, @philippjfr, @maximlt, @MarcSkovMadsen and @philippjfr for continuing to push the development of Panel.\nIf you are using Anaconda, you can get the latest Panel with conda install -c pyviz panel , and using pip you can install it with pip install panel."
  },
  {
    "objectID": "posts/panel_release_0.13/index.html#roadmap",
    "href": "posts/panel_release_0.13/index.html#roadmap",
    "title": "Panel 0.13.0 Release",
    "section": "Roadmap",
    "text": "Roadmap\nThis release has included a ton of great features and likely marks the last minor release before the Panel 1.0 release. Note that 1.0 will introduce major changes and we will be looking to you to provide feedback and help test the release. So look out for announcements of alpha, beta and release candidate releases and help make sure Panel 1.0 will be the success we hope it will be.\n\nDocumentation & Website\nThe Panel documentation has slowly evolved over time with new content and material added whenever new features were added. This means that we never did a full review of the documentation and considered how best to introduce users to the fundamental concepts. Before the 1.0 release we are planning to do a complete overhaul of the documentation and modernize the website.\n\n\nExporting to WASM\nAs highlighted above we now have support for running Panel applications entirely in the browser via Jupyterlite and Pyodide. In the future we hope to extend this support to directly export your existing Panel applications to a standalone HTML file that will run your Python application entirely clientside in your browser.\n\n\nNative applications\nThanks to recent collaboration with the brilliant folks at Quansight and the Beeware project we have a basic prototype for running Panel apps in a native application. We hope to integrate this work into Panel to eventually allow you to build installers for the major operating systems (Linux, OSX and Windows) and hopefully also mobile platforms including iOS and Android.\n\n\nRewrite of the layout engine\nPanel is built on top of Bokeh which was originally a plotting library but included an extremely powerful server architecture that has allowed us to build this entire ecosystem on top of. One of the legacies of Bokeh being primarily a plotting library was that it included a layout engine to ensure plots could be easily aligned. Unfortunately this also had severe downsides, specifically since this so called “managed layout” had to perform expensive computations to measure the size of different components on the page. This is why when you build complex nested layouts using rows, columns and grids you could sometimes slow down your application.\nBokeh has now begun replacing this managed layout with a CSS based unmanaged layout, which will free us from the performance bottlenecks of the past. This will result in a bright new future for Panel but it may also be also be a little disruptive in the short term. As soon as development versions of Bokeh 3.0 and Panel 1.0 are available we would therefore appreciate if you could provide us with feedback about any regressions related to layouts in your own applications so we can minimize the upgrade path.\n\n\nCSS & Styling\nAnother major change resulting from the upgrade to Bokeh 3.0 will be in the way styling is managed. In the past you had the ability to modify styling of Panel/Bokeh components by constructing somewhat brittle CSS rules. This will now be a thing of the past as we will expose the stylesheets for all components directly in Python. This will afford much greater and simplified control over the styling of components but will also disrupt anyone who relied on applying CSS stylesheets directly. We again hope to minimize the disruptions related to this change and will provide a detailed migration guide.\n\n\nHelp us!\nPanel is an open-source project and we are always looking for new contributors. Join us the discussion on the Discourse and we would be very excited to get you started contributing! Also please get in touch with us if you work at an organization that would like to support future Panel development, fund new Panel features, or set up a support contract.\n\n\nSponsors\nMany thanks to our existing sponsors:"
  },
  {
    "objectID": "posts/hv_release_1.13/index.html",
    "href": "posts/hv_release_1.13/index.html",
    "title": "",
    "section": "",
    "text": "TODO\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/hvplot_release_0.8/index.html",
    "href": "posts/hvplot_release_0.8/index.html",
    "title": "hvPlot 0.8.0 Release",
    "section": "",
    "text": "What is hvPlot?\nhvPlot is an open-source library that offers powerful high-level functionality for data exploration and visualization that doesn’t require you to learn a new API. For instance, if you have a Pandas or Xarray data pipeline already, you can turn it into a simple data-exploration app by starting the pipeline with .interactive and replacing method arguments with widgets. Or you can get powerful interactive and compositional Bokeh, Plotly, or Matplotlib plots by simply replacing .plot with .hvplot. hvPlot makes all the analytical power of the HoloViz ecosystem available, using the APIs you already know.\n\nimport hvplot.pandas\nfrom bokeh.sampledata import penguins\n\ndf = penguins.data\ndf.hvplot.scatter(x='bill_length_mm', y='bill_depth_mm', by='species')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nCheck out the hvPlot’s website to find out more!\n\nNew release!\nWe are very pleased to announce the 0.8.0 and 0.8.1 releases of hvPlot! The 0.8.0 release focused on adding a number of powerful features requested by our users, including:\n\nIn addition to Bokeh, hvPlot now supports Matplotlib and Plotly plotting extensions, so that the results of your exploratory analysis can be used alongside highly customized plots from your favorite library.\n.interactive() pipelines can now start with functions as inputs, not just from an existing data structure, so that you can make fully self-contained data apps from using hvPlot alone.\nThe new hvPlot Explorer is a UI component designed to easily explore data without having to write any code; just drop it in your notebook or app and start exploring!\n\nWhile this blog post will focus on those three big features, hvPlot 0.8 includes a number of other enhancements and bug fixes that are of almost equal importance. For a detailed list of the changes, check out the release notes for hvPlot 0.8.0 and 0.8.1.\nMany, many thanks to everyone who filed issues or contributed to this release. In particular we would like to thank @jbednar, @FabianHofmann, @jomey, @ablythed, @jlstevens, @MarcSkovMadsen, @Hoxbro, @michaelaye, @MridulS, @ppwadhwa, @maximlt, @philippjfr for contributing various fixes and improvements!\n\nIf you are using conda, you can get the latest hvPlot with conda install -c pyviz hvplot , and using pip you can install it with pip install hvplot.\n\n\nNew plotting extensions: Matplotlib and Plotly\nYou may be surprised that despite its name, hvPlot is actually not a plotting library! Instead, it is a high-level interface that delegates the actual “plotting” work, i.e. how to display lines, points, etc. on a screen, to lower-level libraries. Until now, hvPlot was only able to delegate that work to Bokeh, one particular interactive plotting library. However, hvPlot happens to be built on top of HoloViews, which for years has had support for Matplotlib and Plotly as well. hvPlot now exposes those capabilities of HoloViews, which opens up new opportunities of hvPlot usage. For instance, you can now explore plots interactively using hvPlot, export them as Matplotlib figures, and then combine the output with other custom Matplotlib figures for a publication-ready workflow.\nWhile Bokeh is still the default plotting backend of hvPlot, with the new hvplot.extension() utility you can now declare, usually at the start of a notebook, the plotting backend you would like to use.\n\nhvplot.extension('matplotlib')\n\n\n\n\n\n\n\n\n\n\n\nThen just use hvPlot as you normally do, including optionally passing styling options that are compatible with the selected plotting backend.\n\nscatter = df.hvplot.scatter(x='bill_length_mm', y='bill_depth_mm', by='species')\nscatter.opts(fig_size=150)\n\n\n\n\nEven if hvPlot allows you to customize your plots quite extensively, there are always situations when you need more! In those cases and in the spirit of the HoloViz mantra shortcuts, not dead-ends, you can get a handle on the actual plotting figure object with hvplot.render() and adapt it further to your liking.\n\n%matplotlib inline\n\nimport matplotlib.pyplot as plt\n\nwith plt.xkcd():\n    fig = hvplot.render(scatter)\n\n\nfig\n\n\n\n\nHead over to hvPlot’s site to learn more about how to manage the extensions and have a look at the Matplotlib and Plotly pages of the site to get an overview of the kind of plots you have access to now.\n\n\nPowerful .interactive() pipeline\nhvPlot 0.7 added an amazing new .interactive() API that is now finally being announced properly. Imagine you are trying to analyze data in a Pandas DataFrame, e.g. in a Jupyter notebook, by calling various Pandas methods to select, aggregate, or plot the data. You will often find yourself having to re-run many commands or notebook cells after changing the method parameters, either to get more insights on the data or to fine tune an algorithm. The .interactive API makes this exploration fast and interactive, giving you a Panel app directly from your data structure’s existing API!\nAs an example, let’s use a time series oftim stock data. In this rather simple data pipeline, we filter the time series by a time range, we upsample the filtered data to one week, and we finally plot the result as an OHLC Open-High-Low-Close (OHLC) chart:\n\nimport yfinance\n\ndf = yfinance.download(\"NVDA\", start=\"2020-01-01\", end=\"2022-04-30\", progress=False)\n\n(\n    df\n    .loc[(df.index&gt;=\"2020-01-01\") & (df.index&lt;=\"2022-04-30\")]\n    .resample('W').agg({'Open': 'first', 'High': 'max', 'Low': 'min', 'Close': 'last'})\n    .hvplot.ohlc(grid=True, title='NVDA')\n)\n\n\n\n\n\n  \n\n\n\n\nThis particular plot is just one of many that we might use to understand the data, and we’d also look at filtering the data on another period and changing the resampling offset value. How this is usually achieved is either by modifying the notebook cell and re-running it, or copy/pasting its content to another cell and accumulating variations of the pipeline in the notebook.\nInstead, you can now define your parameters as widgets and inject them into the pipeline, as long as you first make your pipeline interactive with .interactive(). An interactive pipeline mirrors the API of the underlying data object, which means you can use any method or operators you would normally use from the Pandas DataFrame API.\n\nimport panel as pn\n\n# Create Panel widgets\nw_resample = pn.widgets.RadioButtonGroup(options=['W', 'M'])\nw_dt_range = pn.widgets.DateRangeSlider(start=df.index.min(), end=df.index.max())\n\n# Make the pipeline interactive\ndfi = df.interactive(loc='left')\n\n# Inject the widgets in the interactive pipeline\n(\n    dfi\n    .loc[(dfi.index&gt;=w_dt_range.param.value_start) & (dfi.index&lt;=w_dt_range.param.value_end)]\n    .resample(w_resample).agg({'Open': 'first', 'High': 'max', 'Low': 'min', 'Close': 'last'})\n    .hvplot.ohlc(grid=True, title='NVDA')\n);\n\n\nThe pipeline output consists of the injected widgets and the normal pipeline output. Updating a widget will automatically update the output, in this case the plot. So with just a little bit of preliminary work, i.e. creating the widgets and the interactive object, you can now comfortably explore your data without writing new code for each combination.\nhvPlot allows you to start your pipeline from a variety of data types, including Xarray DataArrays and Datasets, and Pandas, GeoPandas, Dask and Streamz Series and DataFrames. But what if you want the user to make a selection before you have the data in one of these formats, e.g. because you are selecting between files or loading data from a database or a web API? In that case, you can use the new feature from hvPlot 0.8.0: functions can now be passed as inputs to an interactive pipeline. As long as your input function returns one of the data types supported by .interactive(), you can bind whatever arguments it has to widgets using hvplot.bind(). Calling .interactive() on the bound function then declares it as an interactive object that can be used at the start of a pipeline. In the following example we use this new feature to select the stock we want to analyze, defining an input function that will download the data from a web API.\n\n# Create a Panel widget\nw_ticker = pn.widgets.Select(name='Ticker', options=['NVDA', 'AAPL', 'IBM', 'GOOG', 'MSFT'])\n\n# Define a loading function that returns a Pandas DataFrame\ndef load_stock_time_series_from_yahoo(ticker):\n    return yfinance.download(ticker, start=\"2020-01-01\", end=\"2022-04-30\", progress=False)\n\n\n# Bind the function to a widget and make the bound function interactive.\ndfi = hvplot.bind(load_stock_time_series_from_yahoo, w_ticker).interactive(loc='left')\n\n(\n    dfi\n    .loc[(dfi.index&gt;=w_dt_range.param.value_start) & (dfi.index&lt;=w_dt_range.param.value_end)]\n    .resample(w_resample).agg({'Open': 'first', 'High': 'max', 'Low': 'min', 'Close': 'last'})\n    .hvplot.ohlc(grid=True, title=w_ticker)\n);\n\n\n.interactive() has a lot more to offer than what was described above, and you can check out out the documentation to learn more about it.\n\n\nIntroducing the Explorer user interface\nUsing .hvplot() is a simple and intuitive way to create plots. However when you are exploring data, you don’t always know in advance the best way to display it, or even what kind of plot would be best to visualize the data. You will very likely embark on an iterative process that requires choosing a kind of plot, setting various options, running some code, and repeating until you’re satisfied with the output and the insights you get. The hvPlot Explorer is a Graphical User Interface that allows you to easily generate customized plots, which makes it easy to explore both your data and hvPlot’s extensive API.\nTo create an Explorer you pass your data to the high-level hvplot.explorer function, which returns a Panel app that can be displayed in a notebook or served in a web application. On the right-hand side of this app is a preview of the plot you are building, and on the left-hand side are the various options that you can set to customize the plot.\nNote that for the explorer to be displayed in a notebook, you need to load the hvPlot extension, which happens automatically when you execute import hvplot.pandas. If instead of building Bokeh plots you would rather build a Matplotlib or Plotly plot, simply run hvplot.extension('matplotlib') or hvplot.extension('matplotlib') once, before displaying the explorer.\n\nhvexplorer = hvplot.explorer(df)\nhvexplorer;\n\n\nOnce you’ve created a plot you like, you can then export the current state of the explorer in a few different ways. For instance, you could execute hvexplorer.plot_code() to return a code snippet that you can copy/paste in another notebook cell to reproduce that plot:\n&gt;&gt;&gt; hvexplorer.plot_code()\n\"df.hvplot(by=['species'], kind='scatter', title='Penguins', x='bill_length_mm', y=['bill_depth_mm'])\"\n\n\nHelp us!\nhvPlot is an open-source project, and we are always looking for new contributors. Join the discussion on the Discourse and we would be very excited to get you started contributing! Also please get in touch with us if you work at an organization that would like to support future hvPlot development, fund new features, or set up a support contract.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/survey_2022/index.html",
    "href": "posts/survey_2022/index.html",
    "title": "HoloViz Survey 2022",
    "section": "",
    "text": "Authors: Demetris Roumis,\nLate last year, HoloViz hosted its first-ever user survey. A big shout-out to the more than 130 respondents! The survey covered a lot of ground and gave us a peek into how you all interact with HoloViz tools. Plus, it helped spotlight the areas where our documentation could use more attention, especially for our newcomers. We’ve been hard at work implementing some of your suggestions and pushing out new releases.\nTL;DR - Two docs-related themes stood out among the wealth of feedback received: 1. The need for enhanced reference materials. 2. The need for more straightforward guidance on which HoloViz library to use for a given task.\n\n\n\nSelect Survey Results\n\nUsers and their usage of HoloViz\n\nUser field and role\nDuration of HoloViz use\nFirst vs. most used HoloViz library\nhvPlot vs. HoloViews\nHoloViz dev environment\nCommon data and other packages\nSharing your work\nType hints\n\nAbout HoloViz docs\n\nDocs rating\nOverall docs priorities\nPackage-specific docs type priorities\nPackage-specific docs topic priorities\nHoloViz tutorial\n\n\nSurvey Response\n\nProgress and achievements\n\nDocumentation structure revamp\nIn-Browser interactive examples\nCommunity building\n\nFuture plans\n\nEnhancing reference materials\nAssisting with package selection\n\n\n\n\n\n\n\n\nHere are some of the key highlights that we learned about a slice of our user community.\n\n\nHoloViz tools are clearly used across a wide range of domains, including academia, industry, public, and private sectors. The diversity of applications shows the power and adaptability of HoloViz to support data visualization and analysis needs across many areas of work and study. We hope to further broaden its utility, as cross-pollination of ideas and use cases across fields serves to strengthen our ecosystem and drive open-source innovations.\n\n\n\n\n\n\nQuick note\n\n\n\nMany of you wrote in custom responses for several of the questions. We cherish these write-in responses but have either collapsed them into ‘other’ or omitted them in these summary plots so that the displays don’t blow up from a flood of unique categories.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ignore\nclass Bagel(Dataset):\n    group = param.String(default='Bagel')\n    kdims = param.List(default=[Dimension('x')], bounds=(0, 2))\n    vdims = param.List(default=[Dimension('y')])\n\nclass BagelPlot(ColorbarPlot, LegendPlot):\n    inner_annulus = param.Number(default=0.5, bounds=(0, 1))\n    _plot_methods = dict(single='annular_wedge')\n    style_opts = ['cmap'] + line_properties + fill_properties\n\n    def get_data(self, element, ranges, style):\n        vdim = dim(element.vdims[0])\n        normed_dim = np.cumsum(vdim/vdim.sum()) * np.pi * 2\n        angles = normed_dim.apply(element)\n        mapping = dict(x=0, y=0, inner_radius=self.inner_annulus, outer_radius=1, start_angle='start', end_angle='end')\n        data = {'start': np.concatenate([[0], angles[:-1]]), 'end': angles}\n        self._get_hover_data(data, element)\n        return data, mapping, style\n        \n    def get_extents(self, element, ranges, range_type='combined'):\n        for d, rs in ranges.items():\n            rs.pop('factors', None)\n        return (-1, -1, 1, 1)\n\nhv.Store.register({Bagel: BagelPlot}, 'bokeh')\noptions = hv.Store.options('bokeh')\n\noptions.Bagel = hv.Options(\n    'plot', show_legend=True, xaxis=None, yaxis=None,\n    tools=['hover'], frame_width=300, frame_height=300,\n    legend_position='right')\n\n\n#ignore\nquestion = 'What field do you work in?'\ntitle = 'Field of work'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\ndf.dropna(inplace=True)\n\n# shorten long answers\ndf[title] = df[title].astype(str).apply(lambda x: x if len(x) &lt;= max_len+3 else x[:max_len] + '...')\n\nvc = df[title].value_counts()\none_resp = vc[vc == 1].index\ndf[title] = df[title].apply(lambda x: \"Other\" if x in one_resp else x)\n\ndf_value_counts = pd.DataFrame(df[title].value_counts()).reset_index()\ndf_value_counts.columns = [title, 'Count']\ndf_value_counts['Percentage'] = df_value_counts['Count']/df_value_counts['Count'].sum()\ndf_value_counts['Percentage'] = df_value_counts['Percentage'].map('{:.2%}'.format)\n\n\nfield_plot = Bagel(df_value_counts, title).opts(color=title, cmap=cat_cmap, title=title)\nfield_plot\n\n\n\n\n\n  \n\n\n\n\nAdditionally, approximately 60% of our respondents are “scientists” specializing in either data, research, or applied fields, while another significant portion comprises “engineers” from various domains such as software and machine learning. Although the number of student responses in this survey was limited, we recognize the importance of actively engaging this demographic and will try to improve their turnout in the future.\n\n#ignore\nquestion = 'What title best characterizes your role when using HoloViz tools?'\ntitle = 'Work role'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\ndf.dropna(inplace=True)\n\n# shorten long answers\ndf[title] = df[title].astype(str).apply(lambda x: x if len(x) &lt;= max_len+3 else x[:max_len] + '...')\n\nvc = df[title].value_counts()\none_resp = vc[vc == 1].index\ndf[title] = df[title].apply(lambda x: \"Other\" if x in one_resp else x)\n\ndf_value_counts = pd.DataFrame(df[title].value_counts()).reset_index()\ndf_value_counts.columns = [title, 'Count']\ndf_value_counts['Percentage'] = df_value_counts['Count']/df_value_counts['Count'].sum()\ndf_value_counts['Percentage'] = df_value_counts['Percentage'].map('{:.2%}'.format)\n\nrole_plot = Bagel(df_value_counts, title).opts(color=title, cmap=cat_cmap, title=title)\nrole_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nWe were hoping to have a balance of responses from both our experienced users and newer users with fresh perspectives. Luckily, respondents were roughly split half and half on whether they have used HoloViz tools for over a year. The range of experience levels provides a valuable mix of feedback on both the cultivated expertise that comes with long-term use, as well as opportunities to improve the user experience for those just beginning their journey with HoloViz.\n\n#ignore\nquestion = 'For how long have you used HoloViz tools?'\ntitle = 'Duration with HoloViz'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\ndf.dropna(inplace=True)\n\ntenure_answers = ['Less than 6 months', '6 months - 1 year', '1 - 3 years', 'More than 3 years']\ntenure_pretty = ['&lt;6 months', '6-12 months', '1-3 years', '&gt;3 years']\ntenure_mapper = OrderedDict(zip(tenure_answers, tenure_pretty))\ndf[title] = df[title].map(tenure_mapper)\n\nvc = df[title].value_counts()\none_resp = vc[vc == 1].index\ndf[title] = df[title].apply(lambda x: \"Other\" if x in one_resp else x)\n\ndf_value_counts = pd.DataFrame(df[title].value_counts()).reset_index()\ndf_value_counts.columns = [title, 'Count']\ndf_value_counts['Percentage'] = df_value_counts['Count']/df_value_counts['Count'].sum()\ndf_value_counts['Percentage'] = df_value_counts['Percentage'].map('{:.2%}'.format)\n\n# order the durations based on str dict\ndf_value_counts[title] = pd.Categorical(df_value_counts[title], categories=tenure_pretty, ordered=True)\ndf_value_counts = df_value_counts.sort_values(title)\n\ntenure_plot = Bagel(df_value_counts, title).opts(color=title, cmap='Category20', title=title)\ntenure_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nMany of you started your HoloViz journey working with HoloViews (one of the original HoloViz packages), but are now Panel aficionados. Panel has been surging in popularity with everyone and their mother creating cool web apps these days. We are thinking that Panel and hvPlot are probably the appropriate entry points into HoloViz for new users looking to either do dashboarding or data exploration, respectively (more on this thought later).\n\n#ignore\nused_first_q = 'What was the first HoloViz Tool that you used?'\nused_most_q = 'Which specific HoloViz package have you used the most?'\n\ndf = results[[used_first_q, used_most_q]].copy()\ndf.rename({used_first_q:'First', used_most_q: 'Most'}, axis=1, inplace=True)\n\n# Calculate the counts for each source-target pair\nedges_counts = df.groupby(['First', 'Most']).size().reset_index(name='value')\n\n# so hacky.. add whitespace to the first strings to prevent circular dep\nedges_counts['First'] = edges_counts['First'].apply(lambda x: f\" {x}\")\n\n# update cmap dictionary with keys having a whitespace str prefix \" \"\n# so that the sankey works.. otherwise circular dependency\nnew_cmap = {' ' + key: value for key, value in cmap.items()}\ncmap.update(new_cmap)\n\nsankey = hv.Sankey(edges_counts)\n\nsankey.opts(label_position='outer', cmap=cmap, edge_color=dim('Most').str(), \n           node_color=dim('Most').str())\n\n# Compute text coordinates\nleft_label_x = sankey.range('x')[0]  # x-coordinate for the left label\nright_label_x = sankey.range('x')[1]  # x-coordinate for the right label\nlabel_y = sankey.range('y')[1]  # y-coordinate for both labels\nlabel_y += label_y*.1 # adjust up a bit\n\n# Create the text labels\nleft_label = hv.Text(left_label_x, label_y-10, \"First used\")\nright_label = hv.Text(right_label_x, label_y-10, \"Most used\")\nTitle = hv.Text((right_label_x-left_label_x)//2, label_y+15, \"HoloViz Package\")\n\nsankey_labeled = (sankey * left_label * right_label * Title).opts(width=900, height=400)\nsankey_labeled\n\n\n\n\n\n  \n\n\n\n\n\n\n\nHaving separated users based on which package they used the most, we asked: “If you have used both hvPlot and HoloViews, which do you prefer for data exploration?”. Among users who mostly use hvPlot, a significant majority of about 92% expressed a preference for hvPlot for data exploration, indicating a strong correlation between usage and preference. Interestingly, among users who mostly use HoloViews, the majority still preferred HoloViews, but the margin was narrower. This could suggest that while users tend to prefer the tool they use most often, hvPlot has a notable appeal even among those who primarily use HoloViews.”\n\n#ignore\nquestion = 'If you have used both hvPlot and HoloViews, which do you prefer for data exploration?'\nhvPlot_title = 'Mostly uses hvPlot'\nHoloViews_title = 'Mostly uses HoloViews'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: hvPlot_title, df.columns[1]: HoloViews_title})\n\ndef package_counts(df, title):\n    df_counts = pd.DataFrame(df[title].value_counts())\n    df_counts = df_counts.rename(columns={title:'Count'})\n    df_counts['Percentage'] = df_counts['Count']/df_counts['Count'].sum()\n    df_counts['Percentage'] = df_counts['Percentage'].map('{:.2%}'.format)\n    df_counts.index.name = 'Package'\n    df_counts = df_counts.reset_index()\n    df_counts = df_counts.sort_values('Package')\n    return df_counts\n\ndf_counts_hvPlot = package_counts(df, hvPlot_title)\ndf_counts_HoloViews = package_counts(df, HoloViews_title)\n\nholoviews_bagel = Bagel(df_counts_HoloViews, 'Package', ['Count', 'Percentage']).opts(color='Package', cmap=cmap, title=hvPlot_title)\nhvplot_bagel = Bagel(df_counts_hvPlot, 'Package', ['Count', 'Percentage']).opts(color='Package', cmap=cmap, title=HoloViews_title)\nhv_vs_plot = hvplot_bagel + holoviews_bagel\nhv_vs_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nUnderstanding the environments in which our users operate is crucial for optimizing the HoloViz toolset. So, we sought to identify the most common notebook and Python scripting environments among our user base. Jupyter Lab emerged as the favored notebook environment, used by 66% of respondents, suggesting its capabilities align well with HoloViz’s strengths. Meanwhile, over 62% of respondents prefer VS Code for scripting, likely reflecting its robust Python development support.\n\n#ignore\nquestion = \"What notebook environment do you use when working with HoloViz tools?\"\ntitle = \"Notebook for HoloViz\"\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\nnb_premade_answers = [\"Jupyter Notebook\", \n                     \"Jupyter Lab\",\n                     \"VS Code Notebook\", \n                     \"Colab Notebook\",\n                     \"I don't use notebooks\"]\n\ndef count_premade_string_occurrences(df, text_column, string_list):\n    count_df = pd.DataFrame()\n    df[text_column] = df[text_column].str.lower().str.strip()\n    for string in string_list:\n        string_simp = string.lower().strip()\n        count_df[string] = [df[text_column].str.contains(string_simp).sum()]\n    count_df = count_df.transpose()\n    count_df.columns = ['Count']\n    count_df = count_df.sort_values(by='Count')\n    # count_df['Percentage'] = count_df['Count']/len(df) # assumes max one match per response\n    # count_df['Percentage'] = count_df['Percentage'].map('{:.2%}'.format)\n    count_df.index.name = 'Answer'\n\n    return count_df.reset_index()\n\ndf_value_counts = count_premade_string_occurrences(df, title, nb_premade_answers)\n\nnb_holoviz_plot = df_value_counts.hvplot.bar(\n    x='Answer', y='Count', height=300, width=800,\n    invert=True, title=title, xlabel='', line_width=line_width, fontsize=fontsize, color=default_color)\nnb_holoviz_plot\n\n\n\n\n\n  \n\n\n\n\n\n#ignore\nquestion = \"Where do you write Python scripts when working with HoloViz tools?\"\ntitle = \"Scripting with HoloViz\"\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\npremade_answers = [\"Emacs\",\n                  \"PyCharm\",\n                  \"Spyder\",\n                  \"Sublime\",\n                  \"Vim\",\n                  \"VS Code\",\n                  \"I don't use Python scripts\",\n                  \"Jupyter Lab\"]\n\ndf_value_counts = count_premade_string_occurrences(df, title, premade_answers)\n\nscripting_holoviz_plot = df_value_counts.hvplot.bar(\n    x='Answer', y='Count', hover_cols='Percentage', height=300, width=800,\n    invert=True, title=title, xlabel='', line_width=line_width, fontsize=fontsize, color=default_color)\nscripting_holoviz_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nUnsurprisingly, Pandas and NumPy are the most commonly used data libraries with HoloViz, reflecting their foundational role in data science. However, Xarray also shows substantial usage, underscoring its relevance for multi-dimensional array operations. The wide range of other packages used alongside HoloViz, including Matplotlib, Plotly, and scikit-learn, illustrates the versatility of HoloViz tools and their integration within diverse workflows. These insights help us enhance HoloViz’s compatibility with popular libraries and tools, optimizing user experience.\n\n#ignore\nquestion = \"What data library/structure do you commonly use with HoloViz?\"\ntitle = 'Data tools with HoloViz'\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndef dropna_explode_valuecount_sort(df):\n    df = df.dropna()[title].str.split(', ').explode()\n    df_value_counts = pd.DataFrame(df.value_counts()).reset_index()\n    df_value_counts.columns = [title, 'Count']\n    df_value_counts = df_value_counts[df_value_counts['Count']&gt;1]  # remove write-ins\n    df_value_counts.sort_values('Count', inplace=True)\n    return df_value_counts\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\ndata_tools_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n                xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, \n                title=title)\ndata_tools_plot\n\n\n\n\n\n  \n\n\n\n\n\n#ignore\nquestion = \"What other packages do you use alongside HoloViz tools?\"\ntitle = 'Other packages with HoloViz'\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\nother_tools_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n                xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, \n                title=title)\nother_tools_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nUnderstanding how users disseminate their HoloViz work is key to enhancing its collaborative capabilities. Most users tend to share their entire notebooks, highlighting the notebook’s value as a comprehensive record of data analysis that combines code, visualizations, and narrative. Exported HTML and internally hosted apps also emerged as common sharing methods, reflecting the need for static and interactive data presentation formats respectively.\n\n#ignore\nquestion = \"How do you share your HoloViz work with others?\"\ntitle = 'Share HoloViz work'\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\nshare_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n                xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, \n                title=title)\nshare_plot\n\n\n\n\n\n  \n\n\n\n\nWhen it comes to sharing live, running Python apps, Flask emerged as the top choice, likely due to its simplicity and flexibility for web app development. However, a diverse range of other platforms like Amazon Web Services, SSH, and Nginx are also employed, indicating the varied requirements of our users in terms of hosting and deployment. These insights inform our efforts to ensure HoloViz tools are compatible and easy-to-use across various sharing and deployment platforms.\n\n#ignore\nquestion = \"If you share live, running Python apps, what frameworks and platforms do you use?\"\ntitle = 'App sharing tools'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\napp_tools_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n                xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, \n                title=title)\napp_tools_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nAs we transition from understanding how users interact with and disseminate their HoloViz work, we also sought insights into what enhances their experience with Python packages more broadly, especially relating to different forms of documentation. A clear majority, over 70%, affirmed that type hints in a package’s code are beneficial. This feature, which aids in understanding the expected input and output types of functions, can increase code readability, assist in debugging, and improve IDE tooling support. The response from our users highlights the value of this coding practice, and as a result, we will are discussing how best to add type hints into our code base.\n\n#ignore\nquestion = 'When using Python packages, do you benefit if a package has used type hints'\ntitle = 'Type hints'\ndf = results.filter(like = question).copy() # get the col based on partial match\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = pd.DataFrame(df.value_counts(), columns=['Count']).reset_index()\ndf_value_counts['Percentage'] = df_value_counts['Count']/df_value_counts['Count'].sum()\ndf_value_counts['Percentage'] = df_value_counts['Percentage'].map('{:.2%}'.format)\n\ntype_hints_bagel = Bagel(df_value_counts, title, ['Count', 'Percentage']).opts(\n    color=title, cmap=cat_cmap, title=title) # set2\ntype_hints_bagel\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nOne of the primary purposes of this first survey was to help prioritize much-needed updates to our documentation, with a particular focus on improving the new user experience. And clearly, you agree that documentation is the highest priority:\n\n#ignore\nquestion = \"What development activities would help you most right now?\"\ntitle = 'General priorities'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\ndev_priority_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n            xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, title=title)\ndev_priority_plot\n\n\n\n\n\n  \n\n\n\n\n\n\nUsers rated their initial documentation experience with HoloViz on a scale of 1 to 5. The majority had a neutral (35%) or slightly negative (29%) experience, with a quarter of respondents reporting a positive experience (25%). Only a small percentage found their experience to be excellent or unsatisfactory. These results highlight areas for improvement in our documentation to ensure a smoother onboarding experience for new HoloViz users.\n\n#ignore\nquestion = 'How was your documentation experience when you were a new HoloViz user?'\ntitle = 'Docs rating'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndoc_exp_df_counts = df.value_counts().sort_index()\n\n# response percentages\ntotal_count = doc_exp_df_counts.sum()\nresponse_percentages = (doc_exp_df_counts / total_count) * 100\n\nresp_perc_df = pd.DataFrame(response_percentages, columns=['Percentage'])\nresp_perc_df = resp_perc_df.assign(Count=doc_exp_df_counts)\nresp_perc_df = resp_perc_df.reset_index()\n\nbars = hv.Bars(resp_perc_df)\n\nlabels = {1.0: 'Bad', 5.0: 'Excellent'}\nannotations = [hv.Text(x, resp_perc_df.loc[resp_perc_df[title] == x, 'Percentage'].values[0], labels[x], halign='center', valign='bottom')\n               for x in labels.keys()]\n\ndoc_score_plot = (bars * hv.Overlay(annotations)).opts(\n    opts.Bars(width=400, height=300, xlabel='Score', ylabel='Percentage', tools=['hover'], title=title, color=default_color, line_width=line_width),\n    opts.Text(text_font_size='10pt')\n)\ndoc_score_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nOne of the most important docs questions that we asked was overall “What potential changes to our documentation do you think would most improve the new user experience?”. For simplicity, below are the results for the pre-defined answers (although there were many write-ins that we are taking action on).\nThe most favored suggestion, with nearly 59% support, was to improve the reference API material with examples, signifying the need for clear, actionable examples in API documentation. About half of the respondents also sought examples of when and how to switch between different HoloViz tools or a guide on choosing the most appropriate package to work with, indicating a demand for more guidance on using the right tool for a particular task.\n\n#ignore\nquestion = 'What potential changes to our documentation do you think would most improve the new user experience?'\ntitle = 'Docs changes for new users'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\npremade_answers = ['Create a guide on choosing the most appropriate package to work with',\n                   'Create a short tutorial for each individual package',\n                   'Create examples of when and how to switch between different packages',\n                   'Improve the reference API material with examples and type declarations', \n                   'Redesign the appearance and story of homepages']\n\npremade_counts_df = count_premade_string_occurrences(df, title, premade_answers)\n\ndoc_changes = premade_counts_df.sort_values(by='Count').hvplot.bar(\n    x='Answer', y='Count', hover_cols='Percentage', height=300, width=800,\n    invert=True, title=title, xlabel='', fontsize=fontsize, line_width=line_width, color=default_color)\ndoc_changes\n\n\n\n\n\n  \n\n\n\n\n\n\n\nIn our efforts to enhance our documentation, we asked users to rank the types of documentation that would be most helpful for the three most popular HoloViz packages: Panel, HoloViews, and hvPlot. The results indicate diverse needs across these packages.\nFor Panel and hvPlot, ‘How-to’ recipes for specific tasks emerged as a priority (see What has been accomplished). These practical guides can help users navigate specific use-cases and tasks, reinforcing understanding through application. This suggests that users are seeking more actionable guidance on using these packages to address specific challenges or scenarios.\nOn the other hand, HoloViews users found ‘Explanation of concepts and design’ to be the most beneficial. This implies that users find the conceptual underpinnings and design principles of HoloViews critical for the effective use of the package. As we revamp our documentation, these user priorities will guide our focus, ensuring we deliver information that is both useful and relevant to our users.\n\n#ignore\npackages = ['hvPlot', 'HoloViews', 'Panel']\ntitle='Docs type priority'\n\nall_rankings = pd.DataFrame()\n\nfor package in packages:\n    question = f\"For {package}, rank the type of documentation\"\n    df = results.filter(like = question).copy()\n    df = df.apply(pd.to_numeric, errors='coerce')\n    \n    df = df.mean()\n\n    # create the yaxis labels from the question ending, e.g. \"[Beginner tutorials]\"\n    df.index = df.index.str.split('[').str[-1].str.split(']').str[0].str.strip()\n    \n    df = df.reset_index().rename(columns={'index': 'Documentation Type', 0: 'Average Ranking'})\n    df['Package'] = package  # Add a column for package name\n    \n    all_rankings = pd.concat([all_rankings, df])\n\nall_rankings_sorted = all_rankings.sort_values('Average Ranking')\n\ndoctype_priority = all_rankings_sorted.hvplot.bar('Documentation Type', 'Average Ranking', by='Package', invert=True, \n                                                  width=800, height=400, xlabel='', fontsize=fontsize, title=title).opts(\n                                                  multi_level=False, cmap=cmap, line_width=line_width)\ndoctype_priority\n\n\n\n\n\n  \n\n\n\n\n\n\n\nIn addition to understanding the types of documentation our users find most helpful, we were also interested in identifying specific topics within those documentation types where users saw room for improvement. To this end, we segmented respondents based on their most-used package - Panel, hvPlot, or HoloViews - and asked them to identify specific documentation topics needing enhancement.\nPanel users expressed a need for better documentation on app responsivity and building custom components. These topics are central to creating and managing effective Panel applications, and users’ responses indicate the need for clearer or more comprehensive guidance in these areas.\n\n#ignore\n\npackage = 'Panel'\nquestion = f\"For {package}, improvement to which specific documentation topics would you most benefit from\"\ntitle=f\"{package} docs topic priorities\"\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\npanel_priority_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=400, \n                xlabel='', color=cmap[package], line_width=line_width, fontsize=fontsize, title=title)\npanel_priority_plot\n\n\n\n\n\n  \n\n\n\n\nIn contrast, hvPlot and HoloViews users were focused on different topics. A clear need for more guidance on interactivity emerged, suggesting users are keen to leverage the interactive capabilities of these packages but may find the current documentation lacking. In addition, users expressed a desire for better integration with other HoloViz packages, underscoring the importance of cohesive, cross-package documentation. The request for improved guidance on applying customizations points to users’ desire for more personalized, adaptable visualizations.\n\n#ignore\npackage = 'hvPlot'\nquestion = f\"For {package}, improvement to which documentation topics would you most benefit from\"\ntitle=f\"{package} docs topic priorities\"\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\nhvPlot_priority_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=400, \n                xlabel='', color=cmap[package], line_width=line_width, fontsize=fontsize, title=title)\nhvPlot_priority_plot\n\n\n\n\n\n  \n\n\n\n\n\n#ignore\npackage = 'HoloViews'\nquestion = f\"For {package}, improvement to which documentation topics would you most benefit from\"\ntitle=f\"{package} docs topic priorities\"\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\n# Split the strings on commas that are not inside parentheses\nper_answer = df.dropna()[title].apply(lambda x: re.split(',(?![^()]*\\))', x)).explode()\n\ndf_value_counts = pd.DataFrame(per_answer.value_counts()).reset_index()\ndf_value_counts.columns = [title, 'Count']\ndf_value_counts = df_value_counts[df_value_counts['Count']&gt;1]\ndf_value_counts.sort_values('Count', inplace=True)\n\nHoloViews_priority_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=400, \n                xlabel='', color=cmap[package], line_width=line_width, fontsize=fontsize, title=title)\n\nHoloViews_priority_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nWhen asked about their engagement with the HoloViz tutorial, most users reported reading it directly on the website, signifying the convenience and immediacy of this method. However, many also downloaded the tutorial notebooks for a more hands-on, interactive learning experience. Guided talks through the tutorial were another popular choice, underscoring the importance of providing diverse learning formats.\nDespite these varied approaches, fewer users utilized cloud infrastructure for tutorial access, suggesting that this option might need more visibility or user-friendly features. A small fraction were unaware of the tutorial, highlighting an opportunity to improve communication and resource visibility.\n\n#ignore\nquestion = \"Have you checked out the tutorial on HoloViz.org? If so, in what forms have you experience it?\"\ntitle = 'Tutorial'\n\ndf = results.filter(like=question).copy()\ndf.columns = [title]\n\nper_answer = df[title].dropna().str.split(', ').explode()\n# catch answers about not being aware of the tutorial\nnot_aware = [\"didnt know\", \"didn't know\", \"just learned about it\", \"I have not\", \"didn't realize\", \"just looked at it\"]\nlower_responses = per_answer.str.lower()\nnot_aware_count = sum(any(phrase in response for phrase in not_aware) for response in lower_responses)\n\ndf_value_counts = per_answer.value_counts().rename_axis(title).reset_index(name='Count')\ndf_value_counts = df_value_counts[df_value_counts['Count']&gt;1]  # remove write-ins\n\nnot_aware_df = pd.DataFrame({title: [\"write-ins [I was not aware of the tutorial]\"], 'Count': [not_aware_count]})\ndf_value_counts = pd.concat([df_value_counts, not_aware_df], ignore_index=True)\n\ndf_value_counts.sort_values('Count', inplace=True)\n\ntutorial_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n                xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, \n                title=title)\ntutorial_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\nA key point of feedback has been the lack of a user-centric structure in our documentation. Historically, our docs have leaned heavily on comprehensive user guides for each topic, making it challenging for users to locate necessary information and for contributors to identify and fill gaps. In response, we’ve initiated a transition, beginning with Panel’s documentation, to adopt a structure inspired by the Diataxis framework. Diataxis prioritizes understanding user needs and organizes documentation around distinct types such as how-to guides, references, and explanations. Our progress so dar includes migrating user guides to how-to guides, adding an Explanation section, and overhauling the App Gallery:\n\nMigrate user guide to how-to guides (#4244, #4251, #4267, #4290, #4412, #4422, #4759, #4774)\nAdd Explanation section (#2797, #3168, #4664)\nOverhaul App Gallery (#4047, #4565, #4574, #4598, #4683)\n\n\n\n\nThe survey highlighted a desire for fully interactive documentation. We’ve taken strides to ensure that most of Panel’s documentation can be interactively executed directly in the web browser. This has already elicited positive feedback, with other software teams showing interest in adopting this approach:\n\nUse pyodide rendering throughout documentation and add JupyterLite links (#4751)\n\n\n\n\nAligned with survey feedback for further creation and fostering of the HoloViz community, we’ve taken tangible steps to enhance our community. Here’s what we’ve accomplished since the survey:\n\nHosted our inaugural HoloViz sprint at PyData, focusing on documentation.\nEstablished a formal governance structure for HoloViz, including a code of conduct and a steering committee.\nObtained fiscal sponsorship from NumFOCUS, further aligning HoloViz with a broader community of open-source projects and opening opportunities for increased collaboration.\nShifted our user and contributor chats to Discord, enhancing community interaction and transparency.\nConducted a Panel app contest offering substantial prizes.\n\n\n\n\n\n\n\nImproving the reference material is clearly important to users regardless of experience level. Many of you wrote in additional comments related to this theme. For instance:\n\n“It would be great if mentions of various functions, etc in the examples were hyperlinked to an API reference (and the API reference had examples).”\n“extensive description of all supported parameters and expected parameter options”\n“…Stories are great, but without API docs, I can’t figure out what Holoviews is actually doing.”\n“[for hvPlot] since there isn’t a searchable API reference, it’s difficult to figure out how to use them at all or if I should be trying to use them.”\n“…links to reference pages [from other parts of the documentation]”\n“hv.help() should tell you [what to check in the external plotting library documentation]”\n“…make more complete docstrings. It’s usually tough to understand what options are available.”\n“…clear overview of all the possible settings…”\n“Add type hints and stubs to allow static check and autocomplete. That is the most lacking feature of param.”\n\n\n\nWe aim to significantly improve our reference materials by:\n\nCreating API reference pages for all HoloViz libraries\nIncluding links from elsewhere in the docs to the reference material\nEnhancing hv.help() with better outputs, sorting, and parameter support:\n\nAdd output to reference pages (e.g. HoloViews #5423)\nShow the docstring (e.g. HoloViews #5421, #4076)\nSort the output alphabetically (e.g. HoloViews #5420)\nClarify the distinction of different tools args (e.g. HoloViews #4636, #5231)\nEnsure the parameters are supported (e.g. HoloViews #2887)\n\nAlign and organize reference guides (see proposal on Panel #4305)\nStandardize and complete docstrings:\n\nDocument input data format (e.g. HoloViews #3632, #2925, #2116)\nWrite consistent docstrings (e.g. HoloViews #2322, nbsite #67\nAdd type hints to code\n\nCreate a friendly display for Param.Parameterized objects (e.g. Param #425)\nFuzzy matching of not-yet-supported backend-specific options (e.g. HoloViews #4463\n\n\n\n\n\nThere’s notable confusion about choosing the right HoloViz package for a task. Respondents found it difficult to understand the boundaries and overlaps between the packages and to decide which was best for their application:\n\n“The other issue that I know I share with many of my colleagues is the confusion of the HoloViz package separations. For a beginner it is really hard to grasp where the boundaries are and what the individual package is doing in particular, especially because they can have all different sorts of backends (matplotlib, bokeh, pyplot) and seem to have some overlap (holoviews/geoviews).”\n“in general I found it difficult to easily decide which of the many packages was best for my application”\n“…I always struggle with the many different options of doing something…”\n“The number of subproject (panel, colorcet…) is somewhat confusing.”\n“Hard to learn … when to switch to holoviews from hvplot…”\n\n\n\n\nGuide new users to HoloViz.org from our individual library sites to offer a comprehensive view of the ecosystem. Many of our standalone library sites (such as https://datashader.org/) do not sufficiently highlight their part in the wider HoloViz ecosystem or suggest alternative packages that could be more suitable. We aim to address this by prominently signposting HoloViz.org on each library homepage, directing new users to a hub where they can receive guidance on selecting the most appropriate package.\nOverhaul the ‘Getting Started’ section on HoloViz.org to provide clearer guidance on package selection. We understand that our current resources may not adequately guide new users to the most suitable package for their use case. Our plan is to enhance the ‘Getting Started’ experience by recommending most users to begin with either hvPlot or Panel. These two packages collectively offer access to the majority of HoloViz tools and effectively cater to users either in data exploration mode (hvPlot) or app-building stage (Panel). We also aim to clarify the use-case boundaries between packages with overlapping functionality, like hvPlot and HoloViews, to alleviate confusion about initial package selection and subsequent transitioning between them.\nUnify the reactive API across HoloViz to simplify the creation of UI components and data pipelines. We recognize that the current diversity and inconsistency in our approach to building reactive UI components across different packages can complicate package selection and transition between methods. To address this, we’re working on unifying HoloViz’s reactive programming approach. This will make it more intuitive and straightforward to construct reactive data pipelines and UI components across the ecosystem, thereby clarifying the appropriate tool selection for specific workflows. Follow the discussion on Holoviz #370."
  },
  {
    "objectID": "posts/survey_2022/index.html#contents",
    "href": "posts/survey_2022/index.html#contents",
    "title": "HoloViz Survey 2022",
    "section": "",
    "text": "Select Survey Results\n\nUsers and their usage of HoloViz\n\nUser field and role\nDuration of HoloViz use\nFirst vs. most used HoloViz library\nhvPlot vs. HoloViews\nHoloViz dev environment\nCommon data and other packages\nSharing your work\nType hints\n\nAbout HoloViz docs\n\nDocs rating\nOverall docs priorities\nPackage-specific docs type priorities\nPackage-specific docs topic priorities\nHoloViz tutorial\n\n\nSurvey Response\n\nProgress and achievements\n\nDocumentation structure revamp\nIn-Browser interactive examples\nCommunity building\n\nFuture plans\n\nEnhancing reference materials\nAssisting with package selection"
  },
  {
    "objectID": "posts/survey_2022/index.html#select-survey-results",
    "href": "posts/survey_2022/index.html#select-survey-results",
    "title": "HoloViz Survey 2022",
    "section": "",
    "text": "Here are some of the key highlights that we learned about a slice of our user community.\n\n\nHoloViz tools are clearly used across a wide range of domains, including academia, industry, public, and private sectors. The diversity of applications shows the power and adaptability of HoloViz to support data visualization and analysis needs across many areas of work and study. We hope to further broaden its utility, as cross-pollination of ideas and use cases across fields serves to strengthen our ecosystem and drive open-source innovations.\n\n\n\n\n\n\nQuick note\n\n\n\nMany of you wrote in custom responses for several of the questions. We cherish these write-in responses but have either collapsed them into ‘other’ or omitted them in these summary plots so that the displays don’t blow up from a flood of unique categories.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ignore\nclass Bagel(Dataset):\n    group = param.String(default='Bagel')\n    kdims = param.List(default=[Dimension('x')], bounds=(0, 2))\n    vdims = param.List(default=[Dimension('y')])\n\nclass BagelPlot(ColorbarPlot, LegendPlot):\n    inner_annulus = param.Number(default=0.5, bounds=(0, 1))\n    _plot_methods = dict(single='annular_wedge')\n    style_opts = ['cmap'] + line_properties + fill_properties\n\n    def get_data(self, element, ranges, style):\n        vdim = dim(element.vdims[0])\n        normed_dim = np.cumsum(vdim/vdim.sum()) * np.pi * 2\n        angles = normed_dim.apply(element)\n        mapping = dict(x=0, y=0, inner_radius=self.inner_annulus, outer_radius=1, start_angle='start', end_angle='end')\n        data = {'start': np.concatenate([[0], angles[:-1]]), 'end': angles}\n        self._get_hover_data(data, element)\n        return data, mapping, style\n        \n    def get_extents(self, element, ranges, range_type='combined'):\n        for d, rs in ranges.items():\n            rs.pop('factors', None)\n        return (-1, -1, 1, 1)\n\nhv.Store.register({Bagel: BagelPlot}, 'bokeh')\noptions = hv.Store.options('bokeh')\n\noptions.Bagel = hv.Options(\n    'plot', show_legend=True, xaxis=None, yaxis=None,\n    tools=['hover'], frame_width=300, frame_height=300,\n    legend_position='right')\n\n\n#ignore\nquestion = 'What field do you work in?'\ntitle = 'Field of work'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\ndf.dropna(inplace=True)\n\n# shorten long answers\ndf[title] = df[title].astype(str).apply(lambda x: x if len(x) &lt;= max_len+3 else x[:max_len] + '...')\n\nvc = df[title].value_counts()\none_resp = vc[vc == 1].index\ndf[title] = df[title].apply(lambda x: \"Other\" if x in one_resp else x)\n\ndf_value_counts = pd.DataFrame(df[title].value_counts()).reset_index()\ndf_value_counts.columns = [title, 'Count']\ndf_value_counts['Percentage'] = df_value_counts['Count']/df_value_counts['Count'].sum()\ndf_value_counts['Percentage'] = df_value_counts['Percentage'].map('{:.2%}'.format)\n\n\nfield_plot = Bagel(df_value_counts, title).opts(color=title, cmap=cat_cmap, title=title)\nfield_plot\n\n\n\n\n\n  \n\n\n\n\nAdditionally, approximately 60% of our respondents are “scientists” specializing in either data, research, or applied fields, while another significant portion comprises “engineers” from various domains such as software and machine learning. Although the number of student responses in this survey was limited, we recognize the importance of actively engaging this demographic and will try to improve their turnout in the future.\n\n#ignore\nquestion = 'What title best characterizes your role when using HoloViz tools?'\ntitle = 'Work role'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\ndf.dropna(inplace=True)\n\n# shorten long answers\ndf[title] = df[title].astype(str).apply(lambda x: x if len(x) &lt;= max_len+3 else x[:max_len] + '...')\n\nvc = df[title].value_counts()\none_resp = vc[vc == 1].index\ndf[title] = df[title].apply(lambda x: \"Other\" if x in one_resp else x)\n\ndf_value_counts = pd.DataFrame(df[title].value_counts()).reset_index()\ndf_value_counts.columns = [title, 'Count']\ndf_value_counts['Percentage'] = df_value_counts['Count']/df_value_counts['Count'].sum()\ndf_value_counts['Percentage'] = df_value_counts['Percentage'].map('{:.2%}'.format)\n\nrole_plot = Bagel(df_value_counts, title).opts(color=title, cmap=cat_cmap, title=title)\nrole_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nWe were hoping to have a balance of responses from both our experienced users and newer users with fresh perspectives. Luckily, respondents were roughly split half and half on whether they have used HoloViz tools for over a year. The range of experience levels provides a valuable mix of feedback on both the cultivated expertise that comes with long-term use, as well as opportunities to improve the user experience for those just beginning their journey with HoloViz.\n\n#ignore\nquestion = 'For how long have you used HoloViz tools?'\ntitle = 'Duration with HoloViz'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\ndf.dropna(inplace=True)\n\ntenure_answers = ['Less than 6 months', '6 months - 1 year', '1 - 3 years', 'More than 3 years']\ntenure_pretty = ['&lt;6 months', '6-12 months', '1-3 years', '&gt;3 years']\ntenure_mapper = OrderedDict(zip(tenure_answers, tenure_pretty))\ndf[title] = df[title].map(tenure_mapper)\n\nvc = df[title].value_counts()\none_resp = vc[vc == 1].index\ndf[title] = df[title].apply(lambda x: \"Other\" if x in one_resp else x)\n\ndf_value_counts = pd.DataFrame(df[title].value_counts()).reset_index()\ndf_value_counts.columns = [title, 'Count']\ndf_value_counts['Percentage'] = df_value_counts['Count']/df_value_counts['Count'].sum()\ndf_value_counts['Percentage'] = df_value_counts['Percentage'].map('{:.2%}'.format)\n\n# order the durations based on str dict\ndf_value_counts[title] = pd.Categorical(df_value_counts[title], categories=tenure_pretty, ordered=True)\ndf_value_counts = df_value_counts.sort_values(title)\n\ntenure_plot = Bagel(df_value_counts, title).opts(color=title, cmap='Category20', title=title)\ntenure_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nMany of you started your HoloViz journey working with HoloViews (one of the original HoloViz packages), but are now Panel aficionados. Panel has been surging in popularity with everyone and their mother creating cool web apps these days. We are thinking that Panel and hvPlot are probably the appropriate entry points into HoloViz for new users looking to either do dashboarding or data exploration, respectively (more on this thought later).\n\n#ignore\nused_first_q = 'What was the first HoloViz Tool that you used?'\nused_most_q = 'Which specific HoloViz package have you used the most?'\n\ndf = results[[used_first_q, used_most_q]].copy()\ndf.rename({used_first_q:'First', used_most_q: 'Most'}, axis=1, inplace=True)\n\n# Calculate the counts for each source-target pair\nedges_counts = df.groupby(['First', 'Most']).size().reset_index(name='value')\n\n# so hacky.. add whitespace to the first strings to prevent circular dep\nedges_counts['First'] = edges_counts['First'].apply(lambda x: f\" {x}\")\n\n# update cmap dictionary with keys having a whitespace str prefix \" \"\n# so that the sankey works.. otherwise circular dependency\nnew_cmap = {' ' + key: value for key, value in cmap.items()}\ncmap.update(new_cmap)\n\nsankey = hv.Sankey(edges_counts)\n\nsankey.opts(label_position='outer', cmap=cmap, edge_color=dim('Most').str(), \n           node_color=dim('Most').str())\n\n# Compute text coordinates\nleft_label_x = sankey.range('x')[0]  # x-coordinate for the left label\nright_label_x = sankey.range('x')[1]  # x-coordinate for the right label\nlabel_y = sankey.range('y')[1]  # y-coordinate for both labels\nlabel_y += label_y*.1 # adjust up a bit\n\n# Create the text labels\nleft_label = hv.Text(left_label_x, label_y-10, \"First used\")\nright_label = hv.Text(right_label_x, label_y-10, \"Most used\")\nTitle = hv.Text((right_label_x-left_label_x)//2, label_y+15, \"HoloViz Package\")\n\nsankey_labeled = (sankey * left_label * right_label * Title).opts(width=900, height=400)\nsankey_labeled\n\n\n\n\n\n  \n\n\n\n\n\n\n\nHaving separated users based on which package they used the most, we asked: “If you have used both hvPlot and HoloViews, which do you prefer for data exploration?”. Among users who mostly use hvPlot, a significant majority of about 92% expressed a preference for hvPlot for data exploration, indicating a strong correlation between usage and preference. Interestingly, among users who mostly use HoloViews, the majority still preferred HoloViews, but the margin was narrower. This could suggest that while users tend to prefer the tool they use most often, hvPlot has a notable appeal even among those who primarily use HoloViews.”\n\n#ignore\nquestion = 'If you have used both hvPlot and HoloViews, which do you prefer for data exploration?'\nhvPlot_title = 'Mostly uses hvPlot'\nHoloViews_title = 'Mostly uses HoloViews'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: hvPlot_title, df.columns[1]: HoloViews_title})\n\ndef package_counts(df, title):\n    df_counts = pd.DataFrame(df[title].value_counts())\n    df_counts = df_counts.rename(columns={title:'Count'})\n    df_counts['Percentage'] = df_counts['Count']/df_counts['Count'].sum()\n    df_counts['Percentage'] = df_counts['Percentage'].map('{:.2%}'.format)\n    df_counts.index.name = 'Package'\n    df_counts = df_counts.reset_index()\n    df_counts = df_counts.sort_values('Package')\n    return df_counts\n\ndf_counts_hvPlot = package_counts(df, hvPlot_title)\ndf_counts_HoloViews = package_counts(df, HoloViews_title)\n\nholoviews_bagel = Bagel(df_counts_HoloViews, 'Package', ['Count', 'Percentage']).opts(color='Package', cmap=cmap, title=hvPlot_title)\nhvplot_bagel = Bagel(df_counts_hvPlot, 'Package', ['Count', 'Percentage']).opts(color='Package', cmap=cmap, title=HoloViews_title)\nhv_vs_plot = hvplot_bagel + holoviews_bagel\nhv_vs_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nUnderstanding the environments in which our users operate is crucial for optimizing the HoloViz toolset. So, we sought to identify the most common notebook and Python scripting environments among our user base. Jupyter Lab emerged as the favored notebook environment, used by 66% of respondents, suggesting its capabilities align well with HoloViz’s strengths. Meanwhile, over 62% of respondents prefer VS Code for scripting, likely reflecting its robust Python development support.\n\n#ignore\nquestion = \"What notebook environment do you use when working with HoloViz tools?\"\ntitle = \"Notebook for HoloViz\"\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\nnb_premade_answers = [\"Jupyter Notebook\", \n                     \"Jupyter Lab\",\n                     \"VS Code Notebook\", \n                     \"Colab Notebook\",\n                     \"I don't use notebooks\"]\n\ndef count_premade_string_occurrences(df, text_column, string_list):\n    count_df = pd.DataFrame()\n    df[text_column] = df[text_column].str.lower().str.strip()\n    for string in string_list:\n        string_simp = string.lower().strip()\n        count_df[string] = [df[text_column].str.contains(string_simp).sum()]\n    count_df = count_df.transpose()\n    count_df.columns = ['Count']\n    count_df = count_df.sort_values(by='Count')\n    # count_df['Percentage'] = count_df['Count']/len(df) # assumes max one match per response\n    # count_df['Percentage'] = count_df['Percentage'].map('{:.2%}'.format)\n    count_df.index.name = 'Answer'\n\n    return count_df.reset_index()\n\ndf_value_counts = count_premade_string_occurrences(df, title, nb_premade_answers)\n\nnb_holoviz_plot = df_value_counts.hvplot.bar(\n    x='Answer', y='Count', height=300, width=800,\n    invert=True, title=title, xlabel='', line_width=line_width, fontsize=fontsize, color=default_color)\nnb_holoviz_plot\n\n\n\n\n\n  \n\n\n\n\n\n#ignore\nquestion = \"Where do you write Python scripts when working with HoloViz tools?\"\ntitle = \"Scripting with HoloViz\"\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\npremade_answers = [\"Emacs\",\n                  \"PyCharm\",\n                  \"Spyder\",\n                  \"Sublime\",\n                  \"Vim\",\n                  \"VS Code\",\n                  \"I don't use Python scripts\",\n                  \"Jupyter Lab\"]\n\ndf_value_counts = count_premade_string_occurrences(df, title, premade_answers)\n\nscripting_holoviz_plot = df_value_counts.hvplot.bar(\n    x='Answer', y='Count', hover_cols='Percentage', height=300, width=800,\n    invert=True, title=title, xlabel='', line_width=line_width, fontsize=fontsize, color=default_color)\nscripting_holoviz_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nUnsurprisingly, Pandas and NumPy are the most commonly used data libraries with HoloViz, reflecting their foundational role in data science. However, Xarray also shows substantial usage, underscoring its relevance for multi-dimensional array operations. The wide range of other packages used alongside HoloViz, including Matplotlib, Plotly, and scikit-learn, illustrates the versatility of HoloViz tools and their integration within diverse workflows. These insights help us enhance HoloViz’s compatibility with popular libraries and tools, optimizing user experience.\n\n#ignore\nquestion = \"What data library/structure do you commonly use with HoloViz?\"\ntitle = 'Data tools with HoloViz'\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndef dropna_explode_valuecount_sort(df):\n    df = df.dropna()[title].str.split(', ').explode()\n    df_value_counts = pd.DataFrame(df.value_counts()).reset_index()\n    df_value_counts.columns = [title, 'Count']\n    df_value_counts = df_value_counts[df_value_counts['Count']&gt;1]  # remove write-ins\n    df_value_counts.sort_values('Count', inplace=True)\n    return df_value_counts\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\ndata_tools_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n                xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, \n                title=title)\ndata_tools_plot\n\n\n\n\n\n  \n\n\n\n\n\n#ignore\nquestion = \"What other packages do you use alongside HoloViz tools?\"\ntitle = 'Other packages with HoloViz'\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\nother_tools_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n                xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, \n                title=title)\nother_tools_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nUnderstanding how users disseminate their HoloViz work is key to enhancing its collaborative capabilities. Most users tend to share their entire notebooks, highlighting the notebook’s value as a comprehensive record of data analysis that combines code, visualizations, and narrative. Exported HTML and internally hosted apps also emerged as common sharing methods, reflecting the need for static and interactive data presentation formats respectively.\n\n#ignore\nquestion = \"How do you share your HoloViz work with others?\"\ntitle = 'Share HoloViz work'\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\nshare_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n                xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, \n                title=title)\nshare_plot\n\n\n\n\n\n  \n\n\n\n\nWhen it comes to sharing live, running Python apps, Flask emerged as the top choice, likely due to its simplicity and flexibility for web app development. However, a diverse range of other platforms like Amazon Web Services, SSH, and Nginx are also employed, indicating the varied requirements of our users in terms of hosting and deployment. These insights inform our efforts to ensure HoloViz tools are compatible and easy-to-use across various sharing and deployment platforms.\n\n#ignore\nquestion = \"If you share live, running Python apps, what frameworks and platforms do you use?\"\ntitle = 'App sharing tools'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\napp_tools_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n                xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, \n                title=title)\napp_tools_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nAs we transition from understanding how users interact with and disseminate their HoloViz work, we also sought insights into what enhances their experience with Python packages more broadly, especially relating to different forms of documentation. A clear majority, over 70%, affirmed that type hints in a package’s code are beneficial. This feature, which aids in understanding the expected input and output types of functions, can increase code readability, assist in debugging, and improve IDE tooling support. The response from our users highlights the value of this coding practice, and as a result, we will are discussing how best to add type hints into our code base.\n\n#ignore\nquestion = 'When using Python packages, do you benefit if a package has used type hints'\ntitle = 'Type hints'\ndf = results.filter(like = question).copy() # get the col based on partial match\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = pd.DataFrame(df.value_counts(), columns=['Count']).reset_index()\ndf_value_counts['Percentage'] = df_value_counts['Count']/df_value_counts['Count'].sum()\ndf_value_counts['Percentage'] = df_value_counts['Percentage'].map('{:.2%}'.format)\n\ntype_hints_bagel = Bagel(df_value_counts, title, ['Count', 'Percentage']).opts(\n    color=title, cmap=cat_cmap, title=title) # set2\ntype_hints_bagel\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nOne of the primary purposes of this first survey was to help prioritize much-needed updates to our documentation, with a particular focus on improving the new user experience. And clearly, you agree that documentation is the highest priority:\n\n#ignore\nquestion = \"What development activities would help you most right now?\"\ntitle = 'General priorities'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\ndev_priority_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n            xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, title=title)\ndev_priority_plot\n\n\n\n\n\n  \n\n\n\n\n\n\nUsers rated their initial documentation experience with HoloViz on a scale of 1 to 5. The majority had a neutral (35%) or slightly negative (29%) experience, with a quarter of respondents reporting a positive experience (25%). Only a small percentage found their experience to be excellent or unsatisfactory. These results highlight areas for improvement in our documentation to ensure a smoother onboarding experience for new HoloViz users.\n\n#ignore\nquestion = 'How was your documentation experience when you were a new HoloViz user?'\ntitle = 'Docs rating'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndoc_exp_df_counts = df.value_counts().sort_index()\n\n# response percentages\ntotal_count = doc_exp_df_counts.sum()\nresponse_percentages = (doc_exp_df_counts / total_count) * 100\n\nresp_perc_df = pd.DataFrame(response_percentages, columns=['Percentage'])\nresp_perc_df = resp_perc_df.assign(Count=doc_exp_df_counts)\nresp_perc_df = resp_perc_df.reset_index()\n\nbars = hv.Bars(resp_perc_df)\n\nlabels = {1.0: 'Bad', 5.0: 'Excellent'}\nannotations = [hv.Text(x, resp_perc_df.loc[resp_perc_df[title] == x, 'Percentage'].values[0], labels[x], halign='center', valign='bottom')\n               for x in labels.keys()]\n\ndoc_score_plot = (bars * hv.Overlay(annotations)).opts(\n    opts.Bars(width=400, height=300, xlabel='Score', ylabel='Percentage', tools=['hover'], title=title, color=default_color, line_width=line_width),\n    opts.Text(text_font_size='10pt')\n)\ndoc_score_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nOne of the most important docs questions that we asked was overall “What potential changes to our documentation do you think would most improve the new user experience?”. For simplicity, below are the results for the pre-defined answers (although there were many write-ins that we are taking action on).\nThe most favored suggestion, with nearly 59% support, was to improve the reference API material with examples, signifying the need for clear, actionable examples in API documentation. About half of the respondents also sought examples of when and how to switch between different HoloViz tools or a guide on choosing the most appropriate package to work with, indicating a demand for more guidance on using the right tool for a particular task.\n\n#ignore\nquestion = 'What potential changes to our documentation do you think would most improve the new user experience?'\ntitle = 'Docs changes for new users'\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\npremade_answers = ['Create a guide on choosing the most appropriate package to work with',\n                   'Create a short tutorial for each individual package',\n                   'Create examples of when and how to switch between different packages',\n                   'Improve the reference API material with examples and type declarations', \n                   'Redesign the appearance and story of homepages']\n\npremade_counts_df = count_premade_string_occurrences(df, title, premade_answers)\n\ndoc_changes = premade_counts_df.sort_values(by='Count').hvplot.bar(\n    x='Answer', y='Count', hover_cols='Percentage', height=300, width=800,\n    invert=True, title=title, xlabel='', fontsize=fontsize, line_width=line_width, color=default_color)\ndoc_changes\n\n\n\n\n\n  \n\n\n\n\n\n\n\nIn our efforts to enhance our documentation, we asked users to rank the types of documentation that would be most helpful for the three most popular HoloViz packages: Panel, HoloViews, and hvPlot. The results indicate diverse needs across these packages.\nFor Panel and hvPlot, ‘How-to’ recipes for specific tasks emerged as a priority (see What has been accomplished). These practical guides can help users navigate specific use-cases and tasks, reinforcing understanding through application. This suggests that users are seeking more actionable guidance on using these packages to address specific challenges or scenarios.\nOn the other hand, HoloViews users found ‘Explanation of concepts and design’ to be the most beneficial. This implies that users find the conceptual underpinnings and design principles of HoloViews critical for the effective use of the package. As we revamp our documentation, these user priorities will guide our focus, ensuring we deliver information that is both useful and relevant to our users.\n\n#ignore\npackages = ['hvPlot', 'HoloViews', 'Panel']\ntitle='Docs type priority'\n\nall_rankings = pd.DataFrame()\n\nfor package in packages:\n    question = f\"For {package}, rank the type of documentation\"\n    df = results.filter(like = question).copy()\n    df = df.apply(pd.to_numeric, errors='coerce')\n    \n    df = df.mean()\n\n    # create the yaxis labels from the question ending, e.g. \"[Beginner tutorials]\"\n    df.index = df.index.str.split('[').str[-1].str.split(']').str[0].str.strip()\n    \n    df = df.reset_index().rename(columns={'index': 'Documentation Type', 0: 'Average Ranking'})\n    df['Package'] = package  # Add a column for package name\n    \n    all_rankings = pd.concat([all_rankings, df])\n\nall_rankings_sorted = all_rankings.sort_values('Average Ranking')\n\ndoctype_priority = all_rankings_sorted.hvplot.bar('Documentation Type', 'Average Ranking', by='Package', invert=True, \n                                                  width=800, height=400, xlabel='', fontsize=fontsize, title=title).opts(\n                                                  multi_level=False, cmap=cmap, line_width=line_width)\ndoctype_priority\n\n\n\n\n\n  \n\n\n\n\n\n\n\nIn addition to understanding the types of documentation our users find most helpful, we were also interested in identifying specific topics within those documentation types where users saw room for improvement. To this end, we segmented respondents based on their most-used package - Panel, hvPlot, or HoloViews - and asked them to identify specific documentation topics needing enhancement.\nPanel users expressed a need for better documentation on app responsivity and building custom components. These topics are central to creating and managing effective Panel applications, and users’ responses indicate the need for clearer or more comprehensive guidance in these areas.\n\n#ignore\n\npackage = 'Panel'\nquestion = f\"For {package}, improvement to which specific documentation topics would you most benefit from\"\ntitle=f\"{package} docs topic priorities\"\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\npanel_priority_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=400, \n                xlabel='', color=cmap[package], line_width=line_width, fontsize=fontsize, title=title)\npanel_priority_plot\n\n\n\n\n\n  \n\n\n\n\nIn contrast, hvPlot and HoloViews users were focused on different topics. A clear need for more guidance on interactivity emerged, suggesting users are keen to leverage the interactive capabilities of these packages but may find the current documentation lacking. In addition, users expressed a desire for better integration with other HoloViz packages, underscoring the importance of cohesive, cross-package documentation. The request for improved guidance on applying customizations points to users’ desire for more personalized, adaptable visualizations.\n\n#ignore\npackage = 'hvPlot'\nquestion = f\"For {package}, improvement to which documentation topics would you most benefit from\"\ntitle=f\"{package} docs topic priorities\"\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\ndf_value_counts = dropna_explode_valuecount_sort(df)\n\nhvPlot_priority_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=400, \n                xlabel='', color=cmap[package], line_width=line_width, fontsize=fontsize, title=title)\nhvPlot_priority_plot\n\n\n\n\n\n  \n\n\n\n\n\n#ignore\npackage = 'HoloViews'\nquestion = f\"For {package}, improvement to which documentation topics would you most benefit from\"\ntitle=f\"{package} docs topic priorities\"\n\ndf = results.filter(like = question).copy()\ndf = df.rename(columns={df.columns[0]: title})\n\n# Split the strings on commas that are not inside parentheses\nper_answer = df.dropna()[title].apply(lambda x: re.split(',(?![^()]*\\))', x)).explode()\n\ndf_value_counts = pd.DataFrame(per_answer.value_counts()).reset_index()\ndf_value_counts.columns = [title, 'Count']\ndf_value_counts = df_value_counts[df_value_counts['Count']&gt;1]\ndf_value_counts.sort_values('Count', inplace=True)\n\nHoloViews_priority_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=400, \n                xlabel='', color=cmap[package], line_width=line_width, fontsize=fontsize, title=title)\n\nHoloViews_priority_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\nWhen asked about their engagement with the HoloViz tutorial, most users reported reading it directly on the website, signifying the convenience and immediacy of this method. However, many also downloaded the tutorial notebooks for a more hands-on, interactive learning experience. Guided talks through the tutorial were another popular choice, underscoring the importance of providing diverse learning formats.\nDespite these varied approaches, fewer users utilized cloud infrastructure for tutorial access, suggesting that this option might need more visibility or user-friendly features. A small fraction were unaware of the tutorial, highlighting an opportunity to improve communication and resource visibility.\n\n#ignore\nquestion = \"Have you checked out the tutorial on HoloViz.org? If so, in what forms have you experience it?\"\ntitle = 'Tutorial'\n\ndf = results.filter(like=question).copy()\ndf.columns = [title]\n\nper_answer = df[title].dropna().str.split(', ').explode()\n# catch answers about not being aware of the tutorial\nnot_aware = [\"didnt know\", \"didn't know\", \"just learned about it\", \"I have not\", \"didn't realize\", \"just looked at it\"]\nlower_responses = per_answer.str.lower()\nnot_aware_count = sum(any(phrase in response for phrase in not_aware) for response in lower_responses)\n\ndf_value_counts = per_answer.value_counts().rename_axis(title).reset_index(name='Count')\ndf_value_counts = df_value_counts[df_value_counts['Count']&gt;1]  # remove write-ins\n\nnot_aware_df = pd.DataFrame({title: [\"write-ins [I was not aware of the tutorial]\"], 'Count': [not_aware_count]})\ndf_value_counts = pd.concat([df_value_counts, not_aware_df], ignore_index=True)\n\ndf_value_counts.sort_values('Count', inplace=True)\n\ntutorial_plot = df_value_counts.hvplot.bar(title, invert=True, frame_width=300, height=300, \n                xlabel='', color=default_color, line_width=line_width, fontsize=fontsize, \n                title=title)\ntutorial_plot"
  },
  {
    "objectID": "posts/survey_2022/index.html#survey-response",
    "href": "posts/survey_2022/index.html#survey-response",
    "title": "HoloViz Survey 2022",
    "section": "",
    "text": "A key point of feedback has been the lack of a user-centric structure in our documentation. Historically, our docs have leaned heavily on comprehensive user guides for each topic, making it challenging for users to locate necessary information and for contributors to identify and fill gaps. In response, we’ve initiated a transition, beginning with Panel’s documentation, to adopt a structure inspired by the Diataxis framework. Diataxis prioritizes understanding user needs and organizes documentation around distinct types such as how-to guides, references, and explanations. Our progress so dar includes migrating user guides to how-to guides, adding an Explanation section, and overhauling the App Gallery:\n\nMigrate user guide to how-to guides (#4244, #4251, #4267, #4290, #4412, #4422, #4759, #4774)\nAdd Explanation section (#2797, #3168, #4664)\nOverhaul App Gallery (#4047, #4565, #4574, #4598, #4683)\n\n\n\n\nThe survey highlighted a desire for fully interactive documentation. We’ve taken strides to ensure that most of Panel’s documentation can be interactively executed directly in the web browser. This has already elicited positive feedback, with other software teams showing interest in adopting this approach:\n\nUse pyodide rendering throughout documentation and add JupyterLite links (#4751)\n\n\n\n\nAligned with survey feedback for further creation and fostering of the HoloViz community, we’ve taken tangible steps to enhance our community. Here’s what we’ve accomplished since the survey:\n\nHosted our inaugural HoloViz sprint at PyData, focusing on documentation.\nEstablished a formal governance structure for HoloViz, including a code of conduct and a steering committee.\nObtained fiscal sponsorship from NumFOCUS, further aligning HoloViz with a broader community of open-source projects and opening opportunities for increased collaboration.\nShifted our user and contributor chats to Discord, enhancing community interaction and transparency.\nConducted a Panel app contest offering substantial prizes.\n\n\n\n\n\n\n\nImproving the reference material is clearly important to users regardless of experience level. Many of you wrote in additional comments related to this theme. For instance:\n\n“It would be great if mentions of various functions, etc in the examples were hyperlinked to an API reference (and the API reference had examples).”\n“extensive description of all supported parameters and expected parameter options”\n“…Stories are great, but without API docs, I can’t figure out what Holoviews is actually doing.”\n“[for hvPlot] since there isn’t a searchable API reference, it’s difficult to figure out how to use them at all or if I should be trying to use them.”\n“…links to reference pages [from other parts of the documentation]”\n“hv.help() should tell you [what to check in the external plotting library documentation]”\n“…make more complete docstrings. It’s usually tough to understand what options are available.”\n“…clear overview of all the possible settings…”\n“Add type hints and stubs to allow static check and autocomplete. That is the most lacking feature of param.”\n\n\n\nWe aim to significantly improve our reference materials by:\n\nCreating API reference pages for all HoloViz libraries\nIncluding links from elsewhere in the docs to the reference material\nEnhancing hv.help() with better outputs, sorting, and parameter support:\n\nAdd output to reference pages (e.g. HoloViews #5423)\nShow the docstring (e.g. HoloViews #5421, #4076)\nSort the output alphabetically (e.g. HoloViews #5420)\nClarify the distinction of different tools args (e.g. HoloViews #4636, #5231)\nEnsure the parameters are supported (e.g. HoloViews #2887)\n\nAlign and organize reference guides (see proposal on Panel #4305)\nStandardize and complete docstrings:\n\nDocument input data format (e.g. HoloViews #3632, #2925, #2116)\nWrite consistent docstrings (e.g. HoloViews #2322, nbsite #67\nAdd type hints to code\n\nCreate a friendly display for Param.Parameterized objects (e.g. Param #425)\nFuzzy matching of not-yet-supported backend-specific options (e.g. HoloViews #4463\n\n\n\n\n\nThere’s notable confusion about choosing the right HoloViz package for a task. Respondents found it difficult to understand the boundaries and overlaps between the packages and to decide which was best for their application:\n\n“The other issue that I know I share with many of my colleagues is the confusion of the HoloViz package separations. For a beginner it is really hard to grasp where the boundaries are and what the individual package is doing in particular, especially because they can have all different sorts of backends (matplotlib, bokeh, pyplot) and seem to have some overlap (holoviews/geoviews).”\n“in general I found it difficult to easily decide which of the many packages was best for my application”\n“…I always struggle with the many different options of doing something…”\n“The number of subproject (panel, colorcet…) is somewhat confusing.”\n“Hard to learn … when to switch to holoviews from hvplot…”\n\n\n\n\nGuide new users to HoloViz.org from our individual library sites to offer a comprehensive view of the ecosystem. Many of our standalone library sites (such as https://datashader.org/) do not sufficiently highlight their part in the wider HoloViz ecosystem or suggest alternative packages that could be more suitable. We aim to address this by prominently signposting HoloViz.org on each library homepage, directing new users to a hub where they can receive guidance on selecting the most appropriate package.\nOverhaul the ‘Getting Started’ section on HoloViz.org to provide clearer guidance on package selection. We understand that our current resources may not adequately guide new users to the most suitable package for their use case. Our plan is to enhance the ‘Getting Started’ experience by recommending most users to begin with either hvPlot or Panel. These two packages collectively offer access to the majority of HoloViz tools and effectively cater to users either in data exploration mode (hvPlot) or app-building stage (Panel). We also aim to clarify the use-case boundaries between packages with overlapping functionality, like hvPlot and HoloViews, to alleviate confusion about initial package selection and subsequent transitioning between them.\nUnify the reactive API across HoloViz to simplify the creation of UI components and data pipelines. We recognize that the current diversity and inconsistency in our approach to building reactive UI components across different packages can complicate package selection and transition between methods. To address this, we’re working on unifying HoloViz’s reactive programming approach. This will make it more intuitive and straightforward to construct reactive data pipelines and UI components across the ecosystem, thereby clarifying the appropriate tool selection for specific workflows. Follow the discussion on Holoviz #370."
  },
  {
    "objectID": "posts/panel_release_0.7/index.html",
    "href": "posts/panel_release_0.7/index.html",
    "title": "Panel 0.7.0 Release",
    "section": "",
    "text": "We are very pleased to announce the 0.7 release of Panel, which brings a ton of new features, enhancements, and many important bug fixes. Many thanks to the 20 contributors to this release (listed at the bottom). This release introduced only minimal changes in existing APIs, as Panel progresses towards a more stable phase of development. One of the major goals in this release was better compatibility with the Jupyter ecosystem, which culminated in the ipywidgets support. The next major release will be the 1.0 release, which will involve some minor API cleanup and a number of long anticipated features, including a number of polished inbuilt templates and the ability to serve existing Jupyter widgets as part of a Panel app."
  },
  {
    "objectID": "posts/panel_release_0.7/index.html#ipywidget-support",
    "href": "posts/panel_release_0.7/index.html#ipywidget-support",
    "title": "Panel 0.7.0 Release",
    "section": "ipywidget support",
    "text": "ipywidget support\nPanel is built on top of Bokeh, which ships with its own standalone server and has also provided some degree of integration in Jupyter. Panel itself has relied on some custom extensions for Jupyter support which don’t necessarily work in some non-standard notebook and Jupyter environments such as the recently released Voilà dashboard server. After working with the Jupyter and Bokeh developers we have now released the jupyter_bokeh library and extension which allows displaying Bokeh and Panel models as ipywidgets and therefore ensures that bi-directional communication works in any environment that supports the Jupyter widget protocol.\nIn Panel we can enable this globally using pn.extension(comm='ipywidgets') or by explicitly converting a panel object to an ipywidget using pn.ipywidget(obj).\n\nimport ipywidgets as ipw\n\naccordion = ipw.Accordion(children=[\n    pn.ipywidget(pn.Column(\n        pn.widgets.FloatSlider(),\n        pn.widgets.TextInput()\n    )),\n    pn.ipywidget(hv.Curve([1, 2, 3])),\n    pn.ipywidget(hv.Area([1, 2, 3]).opts(responsive=True, min_height=300))\n])\n\naccordion.set_title(0, 'Widgets')\naccordion.set_title(1, 'Curve')\naccordion.set_title(2, 'Area')"
  },
  {
    "objectID": "posts/panel_release_0.7/index.html#support-for-.jscallback-and-improved-.jslink",
    "href": "posts/panel_release_0.7/index.html#support-for-.jscallback-and-improved-.jslink",
    "title": "Panel 0.7.0 Release",
    "section": "Support for .jscallback and improved .jslink",
    "text": "Support for .jscallback and improved .jslink\nPanel has long had support for linking the parameters of two objects in Javascript using the .jslink method. In this release .jslink can now be invoked bi-directionally:\n\nkwargs = dict(start=0, end=1, step=0.1, align='center')\nslider = pn.widgets.FloatSlider(name='Slider', **kwargs)\nspinner = pn.widgets.Spinner(name='Spinner', **kwargs)\n\nslider.jslink(spinner, value='value', bidirectional=True)\n\npn.Row(slider, spinner)\n\n\n\n\n\n\n\n  \n\n\n\n\nThere is also now a .jscallback method, for generating arbitrary JavaScript callbacks in response to some change to a property:\n\nvalue1 =   pn.widgets.Spinner(value=0, width=75)\noperator = pn.widgets.Select(value='*', options=['*', '+'], width=50, align='center')\nvalue2 =   pn.widgets.Spinner(value=0, width=75)\nbutton =   pn.widgets.Button(name='=', width=50)\nresult =   pn.widgets.StaticText(value='0', width=50, align='center')\n\nbutton.jscallback(clicks=\"\"\"\nif (op.value == '*') \n  result.text = (v1.value * v2.value).toString()\nelse\n  result.text = (v1.value + v2.value).toString()\n\"\"\", args={'op': operator, 'result': result, 'v1': value1, 'v2': value2})\n\npn.Row(value1, operator, value2, button, result)"
  },
  {
    "objectID": "posts/panel_release_0.7/index.html#improved-pipelines",
    "href": "posts/panel_release_0.7/index.html#improved-pipelines",
    "title": "Panel 0.7.0 Release",
    "section": "Improved Pipelines",
    "text": "Improved Pipelines\nPreviously the Pipeline class allowed setting up linear pipelines to implement a multi-stage workflow. The Pipeline class was completely overhauled in this release to make it easy to lay out the individual components yourself and most importantly to set up an arbitrary graph of pipeline stages. Pipelines now allow diverging and converging branches for more flexible workflows than before. Below is the definition and the overview of a complex graph-based pipeline with diverging and converging stages:\ndag = pn.pipeline.Pipeline()\n\ndag.add_stage('Input', Input)\ndag.add_stage('Multiply', Multiply)\ndag.add_stage('Add', Add)\ndag.add_stage('Result', Result)\ndag.add_stage('Export', Export)\n\ndag.define_graph({'Input': ('Multiply', 'Add'), 'Multiply': 'Result', 'Add': 'Result', 'Result': 'Export'})"
  },
  {
    "objectID": "posts/panel_release_0.7/index.html#improved-templates",
    "href": "posts/panel_release_0.7/index.html#improved-templates",
    "title": "Panel 0.7.0 Release",
    "section": "Improved Templates",
    "text": "Improved Templates\nSince Panel 0.6 it has been possible to declare custom Templates to take full control over the layout and visual styling of the application or dashboard. In this release we now support rendering custom templates in a notebook and even declaring separate templates for notebook and server usage. In the next release we will focus on providing a number of custom templates built on common JS/CSS frameworks such as Materialize UI, GridStack, and reveal.js."
  },
  {
    "objectID": "posts/panel_release_0.7/index.html#new-components-1",
    "href": "posts/panel_release_0.7/index.html#new-components-1",
    "title": "Panel 0.7.0 Release",
    "section": "New Components",
    "text": "New Components\nThis release includes a variety of new components contributing to the growing set of widgets, panes, and layouts showcased in the reference gallery.\n\nProgress bars\nThe Progress widget displays the progress towards some target based on the current value and the max value. If no value is set the Progress widget is in indeterminate mode and will either be static or animated depending on the active parameter. If you are able to measure or estimate how much progress is remaining on an operation, you can use this widget to give feedback to the user.\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\nDataFrame widget\nThe DataFrame widget allows editing an existing pandas DataFrame using a custom DataTable. Here, each of the numbers and strings are user-editable, which will be reflected in the contents of the DataFrame in Python when there is a live server available.\n\nimport pandas as pd\n\ndf = pd.DataFrame({'int': [1, 2, 3], 'float': [3.14, 6.28, 9.42], 'str': ['A', 'B', 'C']}, index=[1, 2, 3])\n\npn.widgets.DataFrame(df, widths={'index': 10, 'int': 10, 'float': 50, 'str': 100}, width=200)\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\nPasswordInput & TextAreaInput widgets\nNew PasswordInput and TextAreaInput make it possible to enter hidden text and provide multi-line text inputs to Panel:\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\nDataFrame Pane\nThe DataFrame pane renders Pandas, Dask and Streamz dataframes while exposing a range of options to control the formatting.\n\n\n\nStreamz Pane\nThe Streamz pane accepts any streamz Stream to allow streaming arbitrary objects. The basic example in the documentation demonstrates how to quickly put together a streaming vega plot:\n\n\n\n\n\nVideo Pane\nThe Video pane uses a standard HTML5 media player widget to display any mp4, webm, or ogg video file. Like the corresponding Audio pane, the current timestamp, volume, and play state can be toggled from Python and Javascript:\n\nvideo = pn.pane.Video('https://sample-videos.com/video123/mp4/720/big_buck_bunny_720p_1mb.mp4',\n                      width=640, height=480)\n\nvideo\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\nVTKVolume\nThe VTKVolume pane uses the vtk.js library to render interactive, volumetric 3D plots with control over opacity and the color curve.\n\n\n\n\n\nGridBox layout\nThe new GridBox layout complements the existing Row, Column, Tabs, and GridSpec layouts in that it allows wrapping the list of items provided to it by the desired number of rows or columns:\n\nrcolor = lambda: \"#%06x\" % random.randint(0, 0xFFFFFF)\n\nbox = pn.GridBox(*[pn.pane.HTML(background=rcolor(), width=50, height=50) for i in range(22)], ncols=4)\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\nDivider\nThe new Divider component also nicely complements the existing Spacer components making it easy to draw a visual divider between vertically stacked components.\n\npn.Column(\n    pn.layout.Divider(),\n    pn.Row(pn.layout.HSpacer(), '# Title', pn.layout.HSpacer()),\n    pn.layout.Divider()\n)"
  },
  {
    "objectID": "posts/panel_release_0.7/index.html#contributors",
    "href": "posts/panel_release_0.7/index.html#contributors",
    "title": "Panel 0.7.0 Release",
    "section": "Contributors",
    "text": "Contributors\nMany thanks to the many contributors to this release:\n\nPhilipp Rudiger (@philippjfr): Maintainer & lead developer\nXavier Artusi (@xavArtley): VTK support\nJames A. Bednar (@jbednar): Documentation\nAndrew Tolmie (@DancingQuanta): FileInput widget\nArne Recknagel (@a-recknagel): Python 3.8 support, build improvements\nJulius Winkelmann (@julwin): TextAreaInput, PasswordInput\nPav A (@rs2): Example notebooks\nEd Jung (@xtaje): Default values fix\nKarthick Perumal (@Karamya): Audio widget enhancements\nChristopher Ball (@ceball): Build and doc improvements\nAndrew Huang (@ahuang11): Disabling widget boxes\nEduardo Gonzalez (@eddienko): Fixing Django docs\nJacob Barhak (@Jacob-Barhak): Updated Markdown docs\nJean-Luc Stevens (@jstevens): Cross-selector fixes\nJulia Signell (@jsignell): Documentation fixes\nLandung “Don” Setiawan (@lsetiawan): StoppableThread improvements\nMateusz Paprocki (@mattpap): Build infrastructure\nMaxime Borry (@maxibor): Widget fixes\nStefan Farmbauer (@RedBeardCode): File-like object support on images\n@kleavor: Fixed GridSpec override behavior"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "TODO\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHoloViz Survey 2022\n\n\n\nsurvey\n\n\n\n\n\n\n\nDemetris Roumis\n\n\nJul 20, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBuilding an interactive ML dashboard in Panel\n\n\n\nshowcase\n\n\npanel\n\n\n\nBuilding an interactive ML dashboard in Panel\n\n\n\nAndrew Huang, Sophia Yang, Philipp Rudiger\n\n\nJun 6, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhvPlot 0.8.0 Release\n\n\n\nrelease\n\n\nhvplot\n\n\n\nRelease announcement for hvPlot 0.8.0\n\n\n\nMaxime Liquet\n\n\nAug 25, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPanel 0.13.0 Release\n\n\n\nrelease\n\n\npanel\n\n\n\nRelease announcement for Panel 0.13\n\n\n\nPhilipp Rudiger\n\n\nMar 18, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDatashader 0.13 Release\n\n\n\nrelease\n\n\npanel\n\n\n\nRelease announcement for Datashader 0.13\n\n\n\nJames A. Bednar\n\n\nJun 23, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPanel 0.11.0 Release\n\n\n\nrelease\n\n\npanel\n\n\n\nRelease announcement for Panel 0.11\n\n\n\nPhilipp Rudiger\n\n\nFeb 3, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPanel 0.10.0 Release\n\n\n\nrelease\n\n\npanel\n\n\n\nRelease announcement for Panel 0.10\n\n\n\nPhilipp Rudiger\n\n\nOct 22, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPanel 0.8.0 Release\n\n\n\nrelease\n\n\npanel\n\n\n\nRelease announcement for Panel 0.8\n\n\n\nPhilipp Rudiger\n\n\nJan 31, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPanel 0.7.0 Release\n\n\n\nrelease\n\n\npanel\n\n\n\nRelease announcement for Panel 0.7\n\n\n\nPhilipp Rudiger\n\n\nNov 18, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPyViz.org and HoloViz.org\n\n\n\nannouncement\n\n\n\nAnnouncing HoloViz splitting off from PyViz\n\n\n\nJames A. Bednar\n\n\nJul 2, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPanel Announcement\n\n\n\nannouncement\n\n\npanel\n\n\n\nPublic Announcement of the Panel library\n\n\n\nPhilipp Rudiger\n\n\nMay 28, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhvPlot Announcement\n\n\n\nannouncement\n\n\nhvplot\n\n\n\nAnnouncing the release of hvPlot\n\n\n\nPhilipp Rudiger\n\n\nJan 31, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeoViews 1.5 Release\n\n\n\nrelease\n\n\ngeoviews\n\n\n\nRelease announcement for GeoViews 1.5\n\n\n\nPhilipp Rudiger\n\n\nMay 14, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHoloViews 1.10 Release\n\n\n\nrelease\n\n\nholoviews\n\n\n\nRelease announcement for HoloViews 1.10\n\n\n\nPhilipp Rudiger\n\n\nApr 24, 2018\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "posts/gv_release_1.5/index.html",
    "href": "posts/gv_release_1.5/index.html",
    "title": "GeoViews 1.5 Release",
    "section": "",
    "text": "We are very pleased to announce the release of GeoViews 1.5!\nThis release contains a large number of features and improvements. Some highlights include:\nMajor feature:\nNew components:\nNew features:\nEnhancements:\nPlus many other bug fixes, enhancements and documentation improvements. For full details, see the Release Notes.\nIf you are using Anaconda, GeoViews can most easily be installed by executing the command conda install -c pyviz geoviews . Otherwise, you can also use pip install geoviews as long as you satisfy the cartopy dependency yourself."
  },
  {
    "objectID": "posts/gv_release_1.5/index.html#bokeh-support-for-projections",
    "href": "posts/gv_release_1.5/index.html#bokeh-support-for-projections",
    "title": "GeoViews 1.5 Release",
    "section": "Bokeh support for projections",
    "text": "Bokeh support for projections\nIn the past the Bokeh backend for GeoViews only supported displaying plots in Web Mercator coordinates. In this release this limitation was lifted and plots may now be projected to almost all supported Cartopy projections (to see the full list see the user guide):\n\ncities = pd.read_csv(gv_path+'/cities.csv', encoding=\"ISO-8859-1\")\npoints = gv.Points(cities[cities.Year==2050], ['Longitude', 'Latitude'], ['City', 'Population'])\nfeatures = gf.ocean * gf.land * gf.coastline\n\noptions = dict(width=600, height=350, global_extent=True,\n               show_bounds=True, color='black', tools=['hover'], axiswise=True,\n               color_index='Population', size_index='Population', size=0.002, cmap='viridis')\n\n(features * points.options(projection=ccrs.Mollweide(), **options) +\n features * points.options(projection=ccrs.PlateCarree(), **options))"
  },
  {
    "objectID": "posts/gv_release_1.5/index.html#new-elements",
    "href": "posts/gv_release_1.5/index.html#new-elements",
    "title": "GeoViews 1.5 Release",
    "section": "New elements",
    "text": "New elements\nThe other main enhancements to GeoViews in the 1.5 release come from the addition of a wide array of new elements, some of which were recently added in HoloViews and others which have been newly made aware of geographic coordinate systems and added to Geoviews.\n\nGraph\nThe first such addition is the new Graph element which was added to HoloViews 1.9 and has now been made aware of geographic coordinates. The example below (available in the gallery) demonstrates how to use the Graph element to display airport routes from Hawaii with great-circle paths:\n\n\n&lt;div class=\"bk-plotdiv\" id=\"aee12a22-6460-44bb-ae8d-f5df8af8f1ed\"&gt;&lt;/div&gt;\n\n\n\n\n\nVectorField\nAnother element that has been available in HoloViews and now been made aware of geographic coordinates is VectorField, useful for displaying vector quantities on a map. Like most HoloViews and GeoViews elements it can be rendered using both Bokeh (left) and Matplotlib (right):\n\n\n&lt;div class=\"bk-plotdiv\" id=\"95a2f650-d795-4cd1-a103-0982314e76fd\"&gt;&lt;/div&gt;\n\n\n\n\n\nTriMesh\nAlso building on the graph capabilities is the TriMesh element, which allows defining arbitrary meshes from a set of nodes and a set of simplices (triangles defined as lists of node indexes). The TriMesh element allows easily visualizing Delaunay triangulations and even very large meshes, thanks to corresponding support added to datashader. Below we can see a small TriMesh displayed as a wire frame and an interpolated datashaded mesh of the Chesapeake Bay containing 1M triangles:\n\n\n&lt;div class=\"bk-root\"&gt;\n  &lt;div class=\"bk-plotdiv\" id=\"02252e01-de93-4591-a0d6-56383bc62944\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n\n\n\n\nQuadMesh\nGeoViews has long had an Image element that supports regularly sampled, rectilinear meshes similar to matplotlib’s imshow. To plot irregularly sampled rectilinear and curvilinear meshes, GeoViews now also has a QuadMesh element (akin to matplotlib’s pcolormesh). Below is a curvilinear mesh loaded from xarray:\n\n\n&lt;div class=\"bk-plotdiv\" id=\"95bb1fcc-554e-446c-85d0-594f62811ab4\"&gt;&lt;/div&gt;\n\n\n\n\n\nHexTiles\nAnother often requested feature is a hexagonal bin plot, which can be very helpful in visualizing large collections of points. Thanks to the recent addition of a hex tiling glyph in the bokeh 0.12.15 release it was straightforward to add this support in the form of a [HexTiles element]((http://holoviews.org/reference/elements/bokeh/HexTiles.html), which supports both simple bin counts and weighted binning, and fixed or variable hex sizes.\nBelow we can see a HexTiles plot of ~7 million points representing the NYC population, where each hexagonal bin is scaled and colored by the bin value:\n\n\n&lt;div class=\"bk-plotdiv\" id=\"f8bd495f-f86e-4b08-b707-b498a03050d6\"&gt;&lt;/div&gt;\n\n\n\n\n\nLabels\nThe existing Text element allows adding text to a plot, but only one item at a time, which is not suitable for plotting the large collections of text items that many users have been requesting. The new Labels element provides vectorized text plotting, which is probably most often used to annotate data points or regions of another plot type. Here we select the 20 most populous cities in 2050, plot them using the Points element, and use the Labels element to label each point:\n\n\n&lt;div class=\"bk-plotdiv\" id=\"8eb1c3dc-ec2f-4588-af0f-92054dd03ab4\"&gt;&lt;/div&gt;"
  },
  {
    "objectID": "posts/gv_release_1.5/index.html#features",
    "href": "posts/gv_release_1.5/index.html#features",
    "title": "GeoViews 1.5 Release",
    "section": "Features",
    "text": "Features\nApart from the new collection of elements that were added, GeoViews 1.5 also comes with an impressive set of new features and enhancements.\n\nInbuilt Tile Sources\nSince plotting on top of a map tile source is such a common and useful feature, a new tile_sources module has been added to GeoViews. The new geoviews.tile_sources module includes a number of commonly used tile sources from CartoDB, Stamen, ESRI, OpenStreetMap and Wikipedia, a small selection of which is shown below:\n\nimport geoviews.tile_sources as gvts\n\n(gvts.CartoLight + gvts.CartoEco + gvts.ESRI + gvts.OSM + gvts.StamenTerrain + gvts.Wikipedia).cols(3)\n\n\n\n\n\n\n\nDatashader & xESMF regridding\nWhen working with mesh and raster data in a geographic context it is frequently useful to regrid the data. In this release we have improved support for regridding and rasterizing rectilinear and curvilinear grids and trimeshes using the Datashader and xESMF libraries. For a detailed overview of these capabilities see the user guide. As a quick summary:\n\nDatashader provides capabilities to quickly rasterize and regrid data of all kinds (Image, RGB, HSV, QuadMesh, TriMesh, Path, Points and Contours) but does not support complex interpolation and weighting schemes\nxESMF can regrid between general recti- and curvi-linear grids (Image and QuadMesh) with all ESMF regridding algorithms, such as bilinear, conservative and nearest neighbour\n\nBelow you can see the curvilinear mesh displayed above regridded and interpolated using xESMF:\n\n\nReuse existing file: bilinear_(-179.877, 179.749)_(16.334, 89.638)_400x400.nc\n\n\n\n\n&lt;div class=\"bk-root\"&gt;\n  &lt;div class=\"bk-plotdiv\" id=\"e4883890-d172-441f-a981-fdc8811911a5\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n\n\n\n\nHover now displays lat/lon coordinates\nAs you may have noticed when hovering over some of the plots in this blog post, the hover tooltips now automatically format coordinates as latitudes and longitudes rather than the previous (and mostly useless) Web Mercator coordinates.\n\n\nOperations now CRS aware\nIn the past when operations defined in HoloViews were applied to GeoViews elements, the coordinate reference system (CRS) of the data was ignored and a HoloViews element was returned. Thanks to the ability to register pre- and post-processors for operations, operations such as datashade, rasterize, contours and bivariate_kde will now retain the coordinate system of the data.\nAs a simple example we will use the bivariate_kde operation from HoloViews to generate a density map from a set of points. Here the PlateCarree crs is retained throughout the operation so that the returned Contours element is appropriately projected on top of the tile source:\n\nfrom holoviews.operation.stats import bivariate_kde\n\npopulation = gv.Points(cities[cities.Year==2050], ['Longitude', 'Latitude'], 'Population')\n\ngvts.StamenTerrainRetina * bivariate_kde(population, bandwidth=0.1).options(\n    width=500, height=450, show_legend=False, is_global=True\n).relabel('Most populous city density map')\n\n\n\n\n\n\n\nProjection operation improved\nThe gv.project operation provides a high-level wrapper for projecting all GeoViews element types and now has better handling for polygons and paths as well as all the new element types added in this release."
  },
  {
    "objectID": "posts/gv_release_1.5/index.html#improved-documentation-gallery",
    "href": "posts/gv_release_1.5/index.html#improved-documentation-gallery",
    "title": "GeoViews 1.5 Release",
    "section": "Improved documentation & gallery",
    "text": "Improved documentation & gallery\nThis release was also accompanied by an overhaul of the existing documentation, specifically an improved user guide on projections and a whole new gallery with a wide (and expanding) selection of examples."
  },
  {
    "objectID": "posts/pyviz_holoviz/index.html",
    "href": "posts/pyviz_holoviz/index.html",
    "title": "PyViz.org and HoloViz.org",
    "section": "",
    "text": "PyViz.org and HoloViz.org\n\nPyViz is a project originally started by Anaconda, Inc. and now including contributions from a very wide range of external contributors. The project brought together the authors of Datashader, HoloViews, GeoViews, Param, and Colorcet, with the goal of helping people make sense of the confusing Python data visualization landscape. As part of this project, we have added several additional libraries, including Panel and hvPlot.\nHowever, in practice there has been confusion between our work to help make viz more accessible for all Python users and our advocacy for our own particular libraries, approaches, and viewpoints.\nTo help everyone keep things straight, we have split these two goals and approaches into two separate organizations: PyViz and HoloViz.\nLike PyData.org (after which it was named), PyViz.org is an open, non-partisan site owned by NumFocus. PyViz is dedicated to sharing information about Python tools, without making claims or judgments about which tool is better. Anyone can contribute factual information to PyViz.org, in the hopes of educating everyone about what tools and capabilities are available in Python. Plus, any Python visualization tool can request a .pyviz.org domain name, which will redirect to their web site. Anaconda, Inc. currently pays for the server and administers PyViz.org, but as laid out in pyviz/website#2, future governance is open to anyone ready to promote Python data visualization in a balanced way.\nMeanwhile, HoloViz.org is an opinionated guide to the tools we created and how to use them to solve problems in data science. These tools were built around and on top of the many science and engineering tools already available in Python, focusing on adding higher-level interfaces that directly address problems faced by end users. HoloViz tools support flexibly visualizing data of any dimensionality in any combination, putting together dashboards quickly and conveniently, rendering billions of data points as easily as hundreds, maintaining visual representations separately from domain models, and effectively utilizing the full dynamic range available for visual perception.\nWe hope that separating our efforts in this way will help the community be able to use and support PyViz.org as a general resource for all things viz in Python, while still letting us present a strong case for our own approaches to viz on HoloViz.org.\nNow that this is all set up, we’d love feedback! If you spot any errors, omissions, or just improvements that can be made at PyViz.org, please open an issue or PR at https://github.com/pyviz/website. In particular, coverage of 3D/SciVis approaches and native-GUI tools is relatively light so far, and we’d welcome some updates from people experienced in those areas. Together we can cover a lot more ground than any one group alone can, and can help new Python users find just the right tool for their needs!\n– The HoloViz Team\n(James A. Bednar, Philipp Rudiger, Jean-Luc Stevens, Julia Signell, Chris Ball, and Jon Mease)\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/panel_announcement/index.html",
    "href": "posts/panel_announcement/index.html",
    "title": "Panel Announcement",
    "section": "",
    "text": "A high-level app and dashboarding solution for the PyData ecosystem.\nAuthor: Philipp Rudiger\nPanel is a new open-source Python library that lets you create custom interactive web apps and dashboards by connecting user-defined widgets to plots, images, tables, or text. It is the culmination of our multi-year effort to connect data scientists with tools for deploying the output of their analysis and models with internal or external consumers of the analysis without having to learn completely different technology stacks or getting into the weeds of web development. Panel can already be installed using either conda install -c pyviz panel or pip install panel, and like all other PyViz projects it is entirely open-source and BSD-3 licensed. To get started visit the website and find the Panel code on GitHub.\nThe main aim behind Panel was to make it as easy as possible to wrap the outputs of existing tools in the PyData ecosystem as a control panel, app, or dashboard, ensuring that users can seamlessly work with the analysis and visualization tools they are already familiar with. Secondly, Panel aims to make it trivial to go from prototyping a little app to deploying it internally within an organization or sharing it publicly with the entire internet."
  },
  {
    "objectID": "posts/panel_announcement/index.html#architecture",
    "href": "posts/panel_announcement/index.html#architecture",
    "title": "Panel Announcement",
    "section": "Architecture",
    "text": "Architecture\nPanel is built on top of two main libraries:\n\nBokeh provides the model-view-controller framework on which Panel is built, along with many of the core components such as the widgets and layout engine\nParam provides a framework for reactive parameters which are used to define all Panel components.\n\nThe choice to build an API on top of Bokeh instead of simply extending it was driven by a number of core requirements. One of the most important was the ability to transition seamlessly between notebook and deployed server contexts, and doing so efficiently and in a scalable way. Another was the flexibility afforded by being able to dynamically generate a Bokeh representation for each view of a Panel object, encouraging reuse and composability of components. A third reason was to make it clear that Panel supports any viewable Python object, including plots from dozens of different libraries, not just Bokeh plots (Panel uses Bokeh internals and technology, but in no way assumes that you will use it with Bokeh plots).\nMost importantly, however, we wanted to design an API that provides a high degree of both flexibility and simplicity. Many of the most common operations for displaying, saving, and serving a dashboard are exposed directly on Panel objects and uniformly across them, making it simpler to work with them. Additionally, updating and even dynamically adding/removing/replacing the indvidual components of a dashboard are as easy as manipulating a list or dictionary in Python. Of course, Panel should not be seen to be in competition with Bokeh; it simply provides higher-level abstractions on top of Bokeh. If needed, Bokeh components can easily be used from within Panel, and Panel components can easily be converted into Bokeh models which can be embedded in a larger Bokeh application."
  },
  {
    "objectID": "posts/panel_announcement/index.html#comparison-to-other-dashboarding-and-widget-libraries",
    "href": "posts/panel_announcement/index.html#comparison-to-other-dashboarding-and-widget-libraries",
    "title": "Panel Announcement",
    "section": "Comparison to other dashboarding and widget libraries",
    "text": "Comparison to other dashboarding and widget libraries\nPanel is a new library in this space but it is heavily inspired by existing concepts and technologies that have in many cases been around for decades. The three main inspirations for Panel were R’s Shiny library, Jupyter’s ipywidgets library, and Plotly’s Dash and we owe all three libraries/ecosystems much gratitude for pioneering.\n\nShiny\nFor anyone who performs analysis in the R programming language, Shiny provides an incredibly powerful and well polished framework for building web applications. It sets an incredibly high bar, from which Panel has taken large amounts of inspiration. In particular, the reactive patterns in Panel are closely modeled on Shiny, and Panel hopes to provide a similarly easy entrypoint for developing web applications in the Python ecosystem. Despite the similarities, Panel is not merely a Shiny clone for Python. In addition to the different constraints imposed by a different language, Panel takes a much more explicit approach toward the UI layout, which is usually separated into a separate file from the business logic in Shiny.\n\n\nJupyter/ipywidgets\nThe Jupyter ecosystem has led to an explosion in the ability to share and disseminate the results of analysis and been a major driver in pushing Python as the most important programming language in scientific analysis, data science, and machine learning. Within the Jupyter ecosystem, the ipywidgets library has provided the foundation for building interactive components and embedding them in a notebook. The community that has developed around this ecosystem has been a major inspiration and many core ideas in Panel are built on concepts popularized by these libraries, including the ability of objects to display themselves with rich representations, easily defining links between components in JS code, and Panel’s interact API. The main difference between Panel and ipywidgets is that the Panel architecture is not closely coupled to the IPython kernel that runs interactive computations in Jupyter. Although Panel fully supports operation in Jupyter notebooks, it is based on a generalized Python/JS communication method that is also fully supported on standalone non-Jupyter servers, making Panel apps work equally well inside and outside of Jupyter contexts.\n\n\nDash\nLike Panel, Plotly’s 2017 Dash library allows building very complex and highly polished applications straight from Python. Dash is also built on a reactive programming model that (along with Shiny) was a big inspiration for some of the features in Panel. Panel and Dash are quite different in other ways, though. Dash is (by design) focused specifically on support for Plotly plots, while Panel is agnostic about what objects are being displayed, and is designed to support whatever visualization or analysis tools are most appropriate for your workflows. Dash also typically requires much more detailed knowledge of low-level web development, while Panel allows users to simply drop in their components, building a usable dashboard in just a few lines of Pythonic code."
  },
  {
    "objectID": "posts/panel_announcement/index.html#open-source-license-community",
    "href": "posts/panel_announcement/index.html#open-source-license-community",
    "title": "Panel Announcement",
    "section": "Open source license & Community",
    "text": "Open source license & Community\nPanel is BSD licensed and therefore free to use and modify by anyone and everyone. We built Panel to make our consulting work easier and give the individuals in those organization more power, but developing something among a small group of developers only goes so far. We believe everyone benefits when communities join their efforts to build tools together. So if you are interested in contributing to Panel or even just have suggestions for features, fixes, and improvements, join us on GitHub or Gitter.\nThanks for checking out Panel! We will be giving a talk and tutorial about it at SciPy 2019 in July and are actively working on building further materials, including more demos, tutorials, and examples in the coming weeks and months!"
  },
  {
    "objectID": "posts/panel_announcement/index.html#further-resources",
    "href": "posts/panel_announcement/index.html#further-resources",
    "title": "Panel Announcement",
    "section": "Further resources",
    "text": "Further resources\n\nOur documentation is hosted at https://panel.pyviz.org\nThe main development repository for Panel is on GitHub\nJoin us on Twitter @PyViz_org\nFind a collection of demos and examples on GitHub\n\n\nTalks\n\nEasy Dashboards for Any Visualization in AE5, with Panel\nRapid Prototyping and Deployment Using the PyViz Stack and Anaconda Enterprise\nVisualizing & Analyzing Earth Science Data Using PyViz & PyData"
  },
  {
    "objectID": "posts/panel_release_0.12/index.html",
    "href": "posts/panel_release_0.12/index.html",
    "title": "TODO",
    "section": "",
    "text": "TODO\n\n\nWhere is the notebook???\n\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/panel_release_0.8/index.html",
    "href": "posts/panel_release_0.8/index.html",
    "title": "Panel 0.8.0 Release",
    "section": "",
    "text": "We are very pleased to announce the 0.8.0 release of Panel! This release focuses primarily on solidifying existing functionality, significantly improving performance, and fixing a number of important bugs. This release also contains some exciting new functionality and new components. We want to thank the many recent contributors (a full list is provided at the bottom), particularly Marc Skov Madsen (the author of awesome-panel.org) and Xavier Artusi (who has been hard at work at improving VTK support). This release introduced only minimal changes in existing APIs while adding a small number of new ones, reflecting the fact that Panel is now relatively stable and is progressing steadily towards a 1.0 release.\nIf you are using Anaconda, you can get latest Panel with conda install -c pyviz panel , and using pip you can install it with pip install panel."
  },
  {
    "objectID": "posts/panel_release_0.8/index.html#new-components",
    "href": "posts/panel_release_0.8/index.html#new-components",
    "title": "Panel 0.8.0 Release",
    "section": "New components",
    "text": "New components\nThis release contains fewer entirely new components than in other recent releases. Even so, we are very excited about the new functionality offered by these new panes and widgets.\n\nDeckGL\ndeck.gl is a WebGL-powered framework for visual exploratory data analysis of large datasets. With the addition of the DeckGL pane in Panel it is now straightforward to embed deck.gl plots into a Panel app, either specified as raw JSON or using the pydeck bindings. Just like the Plotly and Vega panes, Panel will extract any embedded datasets and use binary serialization to send the dataset to the frontend efficiently.\n\n\n\n\nDeckGL example (as shown in the reference gallery)\n\n\n\nThe DeckGL pane (like other panes) can also be easily and efficiently updated from Python, making it possible to build complex apps quickly and easily. Below is a demo (adapted from a pydeck example) demonstrating Conway’s Game of Life rendered using deck.gl and linked to widgets that control the updates to the plot:\n\n\n\n\nDeckGL Game of Life (as shown in the gallery).\n\n\n\nIn addition to being able to efficiently update the DeckGL plot, Panel’s Deck support also allows accessing click and hover events as well as the current range.\n\n\nJSON\nMany of the components in Panel can be specified using a JSON file (e.g. Vega and Deck.GL plots), and JSON is a very common interchange format for files in general. You could already have viewed the contents of such a file using a Markdown pane or an ACE widget, but Panel now provides a compact JSON pane that lets you explore the contents of such a file in a tree-like format.\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nJSON pane (as shown in the reference gallery).\n\n\n\n\n\nVTKVolume (improved)\nThe VTKVolume pane for 3D volumetric rendering has been greatly improved for this release. In particular, this release includes the ability to view 2D slices and control many other properties from both Python and Javascript:\n\n\n\n\nVTKVolume pane as shown in the reference gallery.\n\n\n\n\n\nFileSelector\nAnother frequently requested feature was adding a file browser which would let you browse files on the server (not the local machine) and select them. The new FileSelector widget lets you explore the specified path and select one or more files:\n\n\n\n\nFileSelector widget as shown in the reference gallery."
  },
  {
    "objectID": "posts/panel_release_0.8/index.html#enhancements",
    "href": "posts/panel_release_0.8/index.html#enhancements",
    "title": "Panel 0.8.0 Release",
    "section": "Enhancements",
    "text": "Enhancements\nThe real focus in this release was addressing a number of important usability issues, such as making Panel’s use of Bokeh’s layout engine more scalable, improving Markdown handling, improving the debugging experience in the notebook, and much more.\n\nPerformance Improvements\nPanel is built on top of Bokeh, which provides a powerful engine to lay out arbitrary objects on an HTML page. However because this layout engine has to solve a lot of constraints simultaneously, it has to measure the size of all the different components on the page. This process has serious performance implications for deeply nested layouts or layouts that contain a lot of raw HTML contents where the size is not known ahead of time. In this release, we have added caching of the extents to many of the core Panel components. As a result, many complex dashboards which weren’t feasible before or required building a custom template can now be built entirely using Panel’s layouts, without performance issues.\nIn many complex, real-world dashboards you should now get significantly improved performance and a much more responsive UI. In our testing, the layout engine for our more complex apps achieved 10-100x speedups.\n\n\nImproved JavaScript-based linking\nPanel has always supported linking directly between components using JavaScript, and the previous release added support for arbitrary JS callbacks in the last release. These links are particular useful for export to static HTML files, as they continue functioning even without a Python server present. However, when compared to the Python API, js-links often had a variety of limitations. Certain widgets would return a value of a different type than they would in Python, and the property names sometimes did not match those in Python. These seemingly small differences meant that Python-based linking would often not translate directly to Javascript. In this release we defined “transforms” for many different components that will automatically smooth over these differences. A much wider range of parameters can now be controlled directly from Javascript, without ever having to call back into Python and without the user having to write any JavaScript linking code.\nThis change has also allowed us to update all the reference gallery examples with section on controls, where users can interactively explore the effect of various parameters directly on the website.\n\naudio = pn.pane.Audio('http://ccrma.stanford.edu/~jos/mp3/pno-cs.mp3', name='Audio')\n\npn.Row(hspace, audio.controls(['loop', 'time', 'paused', 'volume'], jslink=True), audio, hspace)\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nAudio pane controls as shown in the reference gallery.\n\n\n\n\n\nEasier debugging\nIn previous releases of Panel all print output or errors in Python, triggered by a change on the frontend, would get routed to the Javascript console. This was obscure and made it hard to debug apps built in the notebook. Starting in this release Panel will display all print output and errors at the top of the cell where they were triggered. This can be controlled using the panel.config.console_output option, which can be set to 'accumulate' (the default), 'replace', or 'disable'.\n\n\n\n\nOutput handling in the notebook\n\n\n\n\n\nBetter Markdown handling\nThe Markdown support in Panel makes it very easy to add some explanatory text, titles, images, and code to an app or dashboard. In this release the Markdown pane finally supports syntax highlighting for source code by default, and will normalize the indentation to make it easier to define Markdown in multi-line string.\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nMarkdown pane with syntax highlighting\n\n\n\n\n\nResponsive Plotly and Vega\nResponsive plots adapt to the size of their container, such as a browser window, which is important for making dashboards that fill the screen or plots that work well on both desktop and mobile devices. Previously only Bokeh plots could be responsive, but now all interactive plotting libraries can support responsive embedding.\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nResponsive plots as shown in the Vega and Plotly reference gallery.\n\n\n\n\n\nImproved Tabs\nTabs are one of the most versatile layout components in Panel, allowing you to make single pages that work like multi-page apps. Previously, all content would be rendered in every tab, whether or not the tab was currently (or ever!) selected. In this release we added a dynamic option, which ensures that a tab is only populated when it is selected. This option makes it possible to render a larger number of tabs and/or tabs with more content without sending the data to the browser and rendering the contents all at once. For example, below we have created a set of tabs containing complex plots from a number of different libraries. Rendering all of these simultaneously would be expensive, but with the dynamic option any number of such plots can be used in the same app:\n\n\n\n\nDynamic Tabs as shown in the gallery\n\n\n\n\n\npn.serve\nWhen serving from the commandline it has always been possible to serve multiple apps at once (just supply all of their filenames to the panel serve command). However, when developing apps interactively there has so far not been any easy way to serve multiple apps at once. In this release we have added a panel.serve function that accepts a dictionary and will serve each of the apps at the endpoint defined by the key. Additionally, if no root app has been defined (by declaring '/' in the dictionary) it will automatically generate an index to let you select between the apps:\npn.serve({'DeckGL': deckgl_pane, 'Plotly': plotly_pane, 'Vega': vega_pane})\n\n\n\n\nMultiple apps served using pn.serve"
  },
  {
    "objectID": "posts/panel_release_0.8/index.html#documentation",
    "href": "posts/panel_release_0.8/index.html#documentation",
    "title": "Panel 0.8.0 Release",
    "section": "Documentation",
    "text": "Documentation\nA special shoutout goes to Marc Skov Madsen who started the awesome-panel project to demonstrate some of the advanced capabilities in Panel. Another huge thank you to Stephane Junod for adding a new complex multi-app Django example."
  },
  {
    "objectID": "posts/panel_release_0.8/index.html#roadmap",
    "href": "posts/panel_release_0.8/index.html#roadmap",
    "title": "Panel 0.8.0 Release",
    "section": "Roadmap",
    "text": "Roadmap\nWe are steadily marching towards Panel’s 1.0 release in the coming months, with a stable API and feature set. In the meantime, we are hoping to add some important new features:\n\nDefault templates (built on Bootstrap and Materialize CSS frameworks) that make it easy to generate more polished looking apps\nSecurity and authentification features that allow users to use standard OAuth services such as GitHub or Twitter or a simple username/password form\nSupport for using ipywidgets inside a Panel app\nDropping Python 2 support\n\nWe expect to make another release in just a few weeks for compatibility with the upcoming Bokeh 2.0 release."
  },
  {
    "objectID": "posts/panel_release_0.8/index.html#changelog",
    "href": "posts/panel_release_0.8/index.html#changelog",
    "title": "Panel 0.8.0 Release",
    "section": "Changelog",
    "text": "Changelog\n\nMajor Features & Enhancements\n\nAdded new DeckGL pane (#1019, #1027)\nMajor improvements to support for JS linking (#1007)\nHuge performance improvements when nesting a lot of components deeply (#867, #888, #895, #988)\nAdd support for displaying callback errors and print output in the notebook simplifying debugging (#977)\nAdd support for dynamically populating Tabs (#995)\nAdded FileSelector widget to browse the servers file system and select files (#909)\nAdd pn.serve function to serve multiple apps at once on the same serve (#963)\nAdd a JSON pane to display json data in a tree format (#953)\n\n\n\nEnhancements\n\nUpdated Parameter mappings (#999)\nEnsure that closed tabs update Tabs.objects (#973)\nFixed HoloViews axis linking across Template roots (#980)\nMerge FactorRange when linking HoloViews axes (#968)\nExpose title and other kwargs on .show() (#962)\nLet FileInput widget set filename (#956) [@Italirz]\nExpose further bokeh CLI commands and added help (#951)\nEnable responsive sizing for Vega/altair pane (#949)\nAdded encode parameter to SVG pane (#913)\nImprove Markdown handling including syntax highlighting and indentation (#881)\nAdd ability to define Template variables (#815)\nAllow configuring responsive behavior globally (#851)\nEnsure that changes applied in callbacks are reflected on the frontend immediately (#857)\nAdd ability to add axes coordinates to VTK view (#817) [@xavArtley]\nAdd config option for safe_embed which ensures all state is recorded (#1040)\nImplemented __signature__ for tab completion (#1029)\n\n\n\nBug fixes\n\nFixed DataFrame widget selection parameter (#989)\nFixes for rendering long strings on Windows systems (#986)\nEnsure that panel does not modify user objects (#967)\nFix multi-level expand Param subobject (#965)\nEnsure load_notebook is executed only once (#1000)\nFixed bug updating StaticText on server (#964)\nDo not link HoloViews axes with different types (#937)\nEnsure that integer sliders are actually integers (#876)\nEnsure that GridBox contents maintain size (#971)\n\n\n\nCompatibility\n\nCompatibility for new Param API (#992, #998) [@jlstevens]\nChanges for compatibility with Vega5 and altair 4 (#873, #889, #892, #927, #933)\n\n\n\nBackwards compatibility\n\nThe Ace pane has been deprecated in favor of the Ace widget (#908) [@kgullikson88]\n\n\n\nDocs\n\nUpdated Django multiple app example and user guide (#928) [@stefjunod]\nClarify developer installation instructions, and fix up some metadata. (#952, #978)\nAdded Param reference notebook (#944)\nAdded Divider reference notebook"
  },
  {
    "objectID": "posts/panel_release_0.8/index.html#contributors",
    "href": "posts/panel_release_0.8/index.html#contributors",
    "title": "Panel 0.8.0 Release",
    "section": "Contributors",
    "text": "Contributors\nMany thanks to the many contributors to this release:\n\nPhilipp Rudiger (@philippjfr): Maintainer & lead developer\nXavier Artusi (@xavArtley): VTK support\nStephane Junod (@stefjunod): Django documentation\nJames A. Bednar (@jbednar): Documentation\nMarc Skov Madsen (@MarcSkovMadsen): DeckGL pane and Param documentation\nChris Ball (@ceball): Build infrastructure and testing\nJean-Luc Stevens (@jstevens): Param compatibility\nMateusz Paprocki (@mattpap): Build infrastructure\nJacob Barkhak (@JacobBarhak): Progress bars for embedding\nKevin Gullikson (@kgullikson88): Converting Ace pane to widget\nLeopold Talirz (@ltalirz): Fix for FileInput.filename"
  },
  {
    "objectID": "posts/hugging_face_template/index.html",
    "href": "posts/hugging_face_template/index.html",
    "title": "Building an interactive ML dashboard in Panel",
    "section": "",
    "text": "Authors: Andrew Huang, Sophia Yang, Philipp Rudiger\n\n\n\nDemo of the image classification app.\n\n\nHoloViz Panel is a versatile Python library that empowers developers and data scientists to build interactive visualizations with ease. Whether you’re working on machine learning projects, developing web applications, or designing data dashboards, Panel provides a powerful set of tools and features to enhance your data exploration and presentation capabilities. In this blog post, we will delve into the exciting features of HoloViz Panel, explore how it can revolutionize your data visualization workflows, and demonstrate how you can make an app like this using about 100 lines of code.\nTry out the app and check out the code:\n\nHugging Face Space\nApp on Anaconda\nApp on Hugging Face\nCode on Anaconda Notebook\nCode on Hugging Face\n\n\n\nML/AI has become an integral part of data analysis and decision-making processes. With Panel, you can seamlessly integrate ML models and results into your visualizations. In this blog post, we will explore how to make an image classification task using the OpenAI CLIP model.\nCLIP is pretrained on a large dataset of image-text pairs, enabling it to understand images and corresponding textual descriptions and work for various downstream tasks such as image classification.\nThere are two ML-related functions we used to perform the image classification task. The first function load_processor_model enables us to load a pre-trained CLIP model from Hugging Face. The second function get_similarity_score calculates the degree of similarity between the image and a provided list of class labels.\n@pn.cache\ndef load_processor_model(\n    processor_name: str, model_name: str\n) -&gt; Tuple[CLIPProcessor, CLIPModel]:\n    processor = CLIPProcessor.from_pretrained(processor_name)\n    model = CLIPModel.from_pretrained(model_name)\n    return processor, model\n\ndef get_similarity_scores(class_items: List[str], image: Image) -&gt; List[float]:\n    processor, model = load_processor_model(\n        \"openai/clip-vit-base-patch32\", \"openai/clip-vit-base-patch32\"\n    )\n    inputs = processor(\n        text=class_items,\n        images=[image],\n        return_tensors=\"pt\",  # pytorch tensors\n    )\n    outputs = model(**inputs)\n    logits_per_image = outputs.logits_per_image\n    class_likelihoods = logits_per_image.softmax(dim=1).detach().numpy()\n    return class_likelihoods[0]\n\n\n\nOne of the key strengths of Panel is its ability to bind widgets to functions. This functionality provides an intuitive interface for users to manipulate the underlying data and gain deeper insights through interaction.\n\n\nIn our example, we have a process_input function, which formats the similarity score we get from the image classification model to a Panel object with a good-looking UI. The actual function utilizes async; if you’re unfamiliar with async, don’t worry! We will explain it in a later section, but note async is not a requirement of using Panel–Panel simply supports it!\nasync def process_inputs(class_names: List[str], image_url: str):\n    \"\"\"\n    High level function that takes in the user inputs and returns the\n    classification results as panel objects.\n    \"\"\"\n    ...\n    yield results\n\n\n\nThere are two widgets that we use to interact with this function.\n\nimage_url is a TextInput widget, which allows entering any string as the image URL.\nclass_names is another TextInput widget, which accepts possible class names for the model to classify.\n\nimage_url = pn.widgets.TextInput(\n    name=\"Image URL to classify\",\n    value=pn.bind(random_url, randomize_url),\n)\nclass_names = pn.widgets.TextInput(\n    name=\"Comma separated class names\",\n    placeholder=\"Enter possible class names, e.g. cat, dog\",\n    value=\"cat, dog, parrot\",\n)\n\n\n\nBased on the process_inputs function signature, it accepts two parameters: class_names and image_url. We can bind each arg/kwarg to a widget using pn.bind like this:\ninteractive_result = pn.panel(\n    pn.bind(process_inputs, image_url=image_url, class_names=class_names),\n    height=600,\n)\n\nThe first positional argument is the function name.\nThe keyword arguments after match the function’s signature, and thus the widgets’ values are bound to the function’s keyword arguments.\n\nTo clarify, if the widget was named image_url_input instead of image_url, then the call would be:\npn.bind(process_inputs, image_url=image_url_input, ...)\n\n\n\n\nThe aesthetics of your applications and dashboards play a critical role in engaging your audience. Panel enables you to add styling based off popular designs like Material or Fast to your visualizations, allowing you to create visually appealing and professional-looking interfaces.\nIn this example, we used a bootstrap template, where we can control what we’d like to show in multiple areas such as title and main, and we can specify sizes and colors for various components:\npn.extension(design=\"bootstrap\", sizing_mode=\"stretch_width\")\nWe also set the Progress bar design to Material.\nrow_bar = pn.indicators.Progress(\n    ...\n    design=pn.theme.Material,\n)\nNote, you can use styles and stylesheets too!\n\n\n\nSome data processing tasks can be computationally expensive, causing sluggish performance. Panel offers caching mechanisms that allow you to store the results of expensive computations and reuse them when needed, significantly improving the responsiveness of your applications.\nIn our example, we cached the output of the load_processor_model using the pn.cache decorator. This means that we don’t need to download and load the model multiple times. This step will make your app feel much more responsive!\nAdditional note: for further responsiveness, there’s defer_loading and loading indicators.\n@pn.cache\ndef load_processor_model(\n    processor_name: str, model_name: str\n) -&gt; Tuple[CLIPProcessor, CLIPModel]:\n    processor = CLIPProcessor.from_pretrained(processor_name)\n    model = CLIPModel.from_pretrained(model_name)\n    return processor, model\n\n\n\nWhile Panel provides a rich set of interactive features, you may occasionally require additional functionality that can be achieved through JavaScript. It’s easy to integrate JavaScript code with Panel visualizations to extend their capabilities. By bridging the gap between Python and JavaScript, you can create advanced visualizations and add interactive elements that go beyond the scope of Panel’s native functionality.\nAt the bottom of our app, you might have observed a collection of icons representing Panel’s social media accounts, including LinkedIn and Twitter. When you click on any of these icons, you will be automatically redirected to the respective social media profiles. This seamless click and redirect functionality is made possible through Panel’s JavaScript integration with the js_on_click method:\nfooter_row = pn.Row(pn.Spacer(), align=\"center\")\nfor icon, url in ICON_URLS.items():\n    href_button = pn.widgets.Button(icon=icon, width=35, height=35)\n    href_button.js_on_click(code=f\"window.open('{url}')\")\n    footer_row.append(href_button)\nfooter_row.append(pn.Spacer())\n\n\n\nAsynchronous programming has gained popularity due to its ability to handle concurrent tasks efficiently. We’ll discuss the differences between synchronous and asynchronous execution and explore Panel’s support for asynchronous operations. Understanding these concepts will enable you to leverage async capabilities within Panel, providing enhanced performance and responsiveness in your applications.\nUsing async to your function allows collaborative multitasking within a single thread and allows IO tasks to happen in the background. For example, when we fetch a random image to the internet, we don’t know how long we’d need to wait and we don’t want to stop our program while waiting. Async enables concurrent execution, allowing us to perform other tasks while waiting and ensuring a responsive application. Be sure to add the corresponding awaits too.\nasync def open_image_url(image_url: str) -&gt; Image:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(image_url) as resp:\n            return Image.open(io.BytesIO(await resp.read()))\nIf you are unfamiliar with async, it’s also possible to rewrite this in sync too! async is not a requirement of using Panel!\ndef open_image_url(image_url: str) -&gt; Image:\n    with requests.get(image_url) as resp:\n        return Image.open(io.BytesIO(resp.read()))\n\n\n\nHere we only explored one idea; there’s so much more you can try:\n\nInteractive Text Generation: Utilize Hugging Face’s powerful language models, such as GPT or Transformer, to generate interactive text. Combine Panel’s widget binding capabilities with Hugging Face models to create dynamic interfaces where users can input prompts or tweak parameters to generate custom text outputs.\nSentiment Analysis and Text Classification: Build interactive dashboards using Hugging Face’s pre-trained sentiment analysis or text classification models. With Panel, users can input text samples, visualize predicted sentiment or class probabilities, and explore model predictions through interactive visualizations.\nLanguage Translation: Leverage Hugging Face’s translation models to create interactive language translation interfaces. With Panel, users can input text in one language and visualize the translated output, allowing for easy experimentation and exploration of translation quality.\nNamed Entity Recognition (NER): Combine Hugging Face’s NER models with Panel to build interactive NER visualizations. Users can input text and visualize identified entities, highlight entity spans, and explore model predictions through an intuitive interface.\nChatbots and Conversational AI: With Hugging Face’s conversational models, you can create interactive chatbots or conversational agents. Panel enables users to have interactive conversations with the chatbot, visualize responses, and customize the chatbot’s behavior through interactive widgets.\nModel Fine-tuning and Evaluation: Use Panel to create interactive interfaces for fine-tuning and evaluating Hugging Face models. Users can input custom training data, adjust hyperparameters, visualize training progress, and evaluate model performance through interactive visualizations.\nModel Comparison and Benchmarking: Build interactive interfaces with Panel to compare and benchmark different Hugging Face models for specific NLP tasks. Users can input sample inputs, compare model predictions, visualize performance metrics, and explore trade-offs between different models.\n\nCheck out our app gallery for other ideas! Happy experimenting!\n\n\n\nThe Panel community is vibrant and supportive, with experienced developers and data scientists eager to help and share their knowledge. Join us and connect with us:\n\nDiscord\nDiscourse\nTwitter\nLinkedIn\nGithub"
  },
  {
    "objectID": "posts/hugging_face_template/index.html#harnessing-the-power-of-mlai",
    "href": "posts/hugging_face_template/index.html#harnessing-the-power-of-mlai",
    "title": "Building an interactive ML dashboard in Panel",
    "section": "",
    "text": "ML/AI has become an integral part of data analysis and decision-making processes. With Panel, you can seamlessly integrate ML models and results into your visualizations. In this blog post, we will explore how to make an image classification task using the OpenAI CLIP model.\nCLIP is pretrained on a large dataset of image-text pairs, enabling it to understand images and corresponding textual descriptions and work for various downstream tasks such as image classification.\nThere are two ML-related functions we used to perform the image classification task. The first function load_processor_model enables us to load a pre-trained CLIP model from Hugging Face. The second function get_similarity_score calculates the degree of similarity between the image and a provided list of class labels.\n@pn.cache\ndef load_processor_model(\n    processor_name: str, model_name: str\n) -&gt; Tuple[CLIPProcessor, CLIPModel]:\n    processor = CLIPProcessor.from_pretrained(processor_name)\n    model = CLIPModel.from_pretrained(model_name)\n    return processor, model\n\ndef get_similarity_scores(class_items: List[str], image: Image) -&gt; List[float]:\n    processor, model = load_processor_model(\n        \"openai/clip-vit-base-patch32\", \"openai/clip-vit-base-patch32\"\n    )\n    inputs = processor(\n        text=class_items,\n        images=[image],\n        return_tensors=\"pt\",  # pytorch tensors\n    )\n    outputs = model(**inputs)\n    logits_per_image = outputs.logits_per_image\n    class_likelihoods = logits_per_image.softmax(dim=1).detach().numpy()\n    return class_likelihoods[0]"
  },
  {
    "objectID": "posts/hugging_face_template/index.html#binding-widgets-for-interactivity",
    "href": "posts/hugging_face_template/index.html#binding-widgets-for-interactivity",
    "title": "Building an interactive ML dashboard in Panel",
    "section": "",
    "text": "One of the key strengths of Panel is its ability to bind widgets to functions. This functionality provides an intuitive interface for users to manipulate the underlying data and gain deeper insights through interaction.\n\n\nIn our example, we have a process_input function, which formats the similarity score we get from the image classification model to a Panel object with a good-looking UI. The actual function utilizes async; if you’re unfamiliar with async, don’t worry! We will explain it in a later section, but note async is not a requirement of using Panel–Panel simply supports it!\nasync def process_inputs(class_names: List[str], image_url: str):\n    \"\"\"\n    High level function that takes in the user inputs and returns the\n    classification results as panel objects.\n    \"\"\"\n    ...\n    yield results\n\n\n\nThere are two widgets that we use to interact with this function.\n\nimage_url is a TextInput widget, which allows entering any string as the image URL.\nclass_names is another TextInput widget, which accepts possible class names for the model to classify.\n\nimage_url = pn.widgets.TextInput(\n    name=\"Image URL to classify\",\n    value=pn.bind(random_url, randomize_url),\n)\nclass_names = pn.widgets.TextInput(\n    name=\"Comma separated class names\",\n    placeholder=\"Enter possible class names, e.g. cat, dog\",\n    value=\"cat, dog, parrot\",\n)\n\n\n\nBased on the process_inputs function signature, it accepts two parameters: class_names and image_url. We can bind each arg/kwarg to a widget using pn.bind like this:\ninteractive_result = pn.panel(\n    pn.bind(process_inputs, image_url=image_url, class_names=class_names),\n    height=600,\n)\n\nThe first positional argument is the function name.\nThe keyword arguments after match the function’s signature, and thus the widgets’ values are bound to the function’s keyword arguments.\n\nTo clarify, if the widget was named image_url_input instead of image_url, then the call would be:\npn.bind(process_inputs, image_url=image_url_input, ...)"
  },
  {
    "objectID": "posts/hugging_face_template/index.html#adding-template-design-styling",
    "href": "posts/hugging_face_template/index.html#adding-template-design-styling",
    "title": "Building an interactive ML dashboard in Panel",
    "section": "",
    "text": "The aesthetics of your applications and dashboards play a critical role in engaging your audience. Panel enables you to add styling based off popular designs like Material or Fast to your visualizations, allowing you to create visually appealing and professional-looking interfaces.\nIn this example, we used a bootstrap template, where we can control what we’d like to show in multiple areas such as title and main, and we can specify sizes and colors for various components:\npn.extension(design=\"bootstrap\", sizing_mode=\"stretch_width\")\nWe also set the Progress bar design to Material.\nrow_bar = pn.indicators.Progress(\n    ...\n    design=pn.theme.Material,\n)\nNote, you can use styles and stylesheets too!"
  },
  {
    "objectID": "posts/hugging_face_template/index.html#caching-for-expensive-tasks",
    "href": "posts/hugging_face_template/index.html#caching-for-expensive-tasks",
    "title": "Building an interactive ML dashboard in Panel",
    "section": "",
    "text": "Some data processing tasks can be computationally expensive, causing sluggish performance. Panel offers caching mechanisms that allow you to store the results of expensive computations and reuse them when needed, significantly improving the responsiveness of your applications.\nIn our example, we cached the output of the load_processor_model using the pn.cache decorator. This means that we don’t need to download and load the model multiple times. This step will make your app feel much more responsive!\nAdditional note: for further responsiveness, there’s defer_loading and loading indicators.\n@pn.cache\ndef load_processor_model(\n    processor_name: str, model_name: str\n) -&gt; Tuple[CLIPProcessor, CLIPModel]:\n    processor = CLIPProcessor.from_pretrained(processor_name)\n    model = CLIPModel.from_pretrained(model_name)\n    return processor, model"
  },
  {
    "objectID": "posts/hugging_face_template/index.html#bridging-functionality-with-javascript",
    "href": "posts/hugging_face_template/index.html#bridging-functionality-with-javascript",
    "title": "Building an interactive ML dashboard in Panel",
    "section": "",
    "text": "While Panel provides a rich set of interactive features, you may occasionally require additional functionality that can be achieved through JavaScript. It’s easy to integrate JavaScript code with Panel visualizations to extend their capabilities. By bridging the gap between Python and JavaScript, you can create advanced visualizations and add interactive elements that go beyond the scope of Panel’s native functionality.\nAt the bottom of our app, you might have observed a collection of icons representing Panel’s social media accounts, including LinkedIn and Twitter. When you click on any of these icons, you will be automatically redirected to the respective social media profiles. This seamless click and redirect functionality is made possible through Panel’s JavaScript integration with the js_on_click method:\nfooter_row = pn.Row(pn.Spacer(), align=\"center\")\nfor icon, url in ICON_URLS.items():\n    href_button = pn.widgets.Button(icon=icon, width=35, height=35)\n    href_button.js_on_click(code=f\"window.open('{url}')\")\n    footer_row.append(href_button)\nfooter_row.append(pn.Spacer())"
  },
  {
    "objectID": "posts/hugging_face_template/index.html#understanding-sync-vs.-async-support",
    "href": "posts/hugging_face_template/index.html#understanding-sync-vs.-async-support",
    "title": "Building an interactive ML dashboard in Panel",
    "section": "",
    "text": "Asynchronous programming has gained popularity due to its ability to handle concurrent tasks efficiently. We’ll discuss the differences between synchronous and asynchronous execution and explore Panel’s support for asynchronous operations. Understanding these concepts will enable you to leverage async capabilities within Panel, providing enhanced performance and responsiveness in your applications.\nUsing async to your function allows collaborative multitasking within a single thread and allows IO tasks to happen in the background. For example, when we fetch a random image to the internet, we don’t know how long we’d need to wait and we don’t want to stop our program while waiting. Async enables concurrent execution, allowing us to perform other tasks while waiting and ensuring a responsive application. Be sure to add the corresponding awaits too.\nasync def open_image_url(image_url: str) -&gt; Image:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(image_url) as resp:\n            return Image.open(io.BytesIO(await resp.read()))\nIf you are unfamiliar with async, it’s also possible to rewrite this in sync too! async is not a requirement of using Panel!\ndef open_image_url(image_url: str) -&gt; Image:\n    with requests.get(image_url) as resp:\n        return Image.open(io.BytesIO(resp.read()))"
  },
  {
    "objectID": "posts/hugging_face_template/index.html#other-ideas-to-try",
    "href": "posts/hugging_face_template/index.html#other-ideas-to-try",
    "title": "Building an interactive ML dashboard in Panel",
    "section": "",
    "text": "Here we only explored one idea; there’s so much more you can try:\n\nInteractive Text Generation: Utilize Hugging Face’s powerful language models, such as GPT or Transformer, to generate interactive text. Combine Panel’s widget binding capabilities with Hugging Face models to create dynamic interfaces where users can input prompts or tweak parameters to generate custom text outputs.\nSentiment Analysis and Text Classification: Build interactive dashboards using Hugging Face’s pre-trained sentiment analysis or text classification models. With Panel, users can input text samples, visualize predicted sentiment or class probabilities, and explore model predictions through interactive visualizations.\nLanguage Translation: Leverage Hugging Face’s translation models to create interactive language translation interfaces. With Panel, users can input text in one language and visualize the translated output, allowing for easy experimentation and exploration of translation quality.\nNamed Entity Recognition (NER): Combine Hugging Face’s NER models with Panel to build interactive NER visualizations. Users can input text and visualize identified entities, highlight entity spans, and explore model predictions through an intuitive interface.\nChatbots and Conversational AI: With Hugging Face’s conversational models, you can create interactive chatbots or conversational agents. Panel enables users to have interactive conversations with the chatbot, visualize responses, and customize the chatbot’s behavior through interactive widgets.\nModel Fine-tuning and Evaluation: Use Panel to create interactive interfaces for fine-tuning and evaluating Hugging Face models. Users can input custom training data, adjust hyperparameters, visualize training progress, and evaluate model performance through interactive visualizations.\nModel Comparison and Benchmarking: Build interactive interfaces with Panel to compare and benchmark different Hugging Face models for specific NLP tasks. Users can input sample inputs, compare model predictions, visualize performance metrics, and explore trade-offs between different models.\n\nCheck out our app gallery for other ideas! Happy experimenting!"
  },
  {
    "objectID": "posts/hugging_face_template/index.html#join-our-community",
    "href": "posts/hugging_face_template/index.html#join-our-community",
    "title": "Building an interactive ML dashboard in Panel",
    "section": "",
    "text": "The Panel community is vibrant and supportive, with experienced developers and data scientists eager to help and share their knowledge. Join us and connect with us:\n\nDiscord\nDiscourse\nTwitter\nLinkedIn\nGithub"
  },
  {
    "objectID": "posts/hvplot_announcement/index.html",
    "href": "posts/hvplot_announcement/index.html",
    "title": "hvPlot Announcement",
    "section": "",
    "text": "A high-level plotting API for the PyData ecosystem - built on HoloViews.\nWe are very pleased to introduce a new visualization tool called hvPlot. hvPlot is closely modeled on the Pandas and Xarray .plot APIs, but returns HoloViews objects that display as fully interactive Bokeh-based plots. hvPlot is significantly more powerful than other .plot API tools that have recently become available, because it lets you use data from a wide array of libraries in the PyData ecosystem:"
  },
  {
    "objectID": "posts/hvplot_announcement/index.html#try-it-out",
    "href": "posts/hvplot_announcement/index.html#try-it-out",
    "title": "hvPlot Announcement",
    "section": "Try it out",
    "text": "Try it out\nWe hope you’ll give hvPlot a try and it makes your visualization workflows a little bit easier and more interactive. Let us know how it goes and don’t hesitate to file issues or make suggestions for improvements for the library. To get started, follow the installation instructions below and visit the website. Also check out pyviz.org for information about the other PyViz libraries, all of which work well with hvPlot.\n\nInstallation\nhvPlot supports Python 2.7, 3.5, 3.6 and 3.7 on Linux, Windows, or Mac and can be installed with conda:\nconda install -c pyviz hvplot\nor with pip:\npip install hvplot\nFor JupyterLab support, the jupyterlab_pyviz extension is also required::\njupyter labextension install @pyviz/jupyterlab_pyviz\n\n\nAcknowledgements\nhvPlot was built with the support of Anaconda Inc.. Special thanks to all the contributors:\n\nPhilipp Rudiger (@philippjfr)\nJulia Signell (@jsignell)\nJames A. Bednar (@jbednar)\nAndrew Huang (@ahuang11)\nJean-Luc Stevens (@jlstevens)"
  },
  {
    "objectID": "posts/panel_release_0.11/index.html",
    "href": "posts/panel_release_0.11/index.html",
    "title": "Panel 0.11.0 Release",
    "section": "",
    "text": "What is Panel?\nPanel is an open-source library that lets you create custom interactive web apps and dashboards by connecting widgets to plots, images, tables, and text - all while writing only Python!\nPanel integrates seamlessly with your existing work:\nPlease check out the Panel website to find out more.\nNew release!\nWe are very pleased to announce the 0.11 release of Panel! This release focuses on adding a number of powerful features requested by our users, including:\nCrucially this release also provides compatibility with Bokeh&gt;=2.3. For a full overview of the changes in this release view the release notes.\nMany, many thanks to the people who contributed to this release, including @philippjfr (author, maintainer, release manager), @MarcSkovMadsen, @xavArtley, @hyamanieu, @cloud-rocket, @kcpevey, @kaseyrussell, @miliante, and @AjayThorve.\nIf you are using Anaconda, you can get the latest Panel with conda install -c pyviz panel , and using pip you can install it with pip install panel."
  },
  {
    "objectID": "posts/panel_release_0.11/index.html#autoreload",
    "href": "posts/panel_release_0.11/index.html#autoreload",
    "title": "Panel 0.11.0 Release",
    "section": "Autoreload",
    "text": "Autoreload\nDeveloping applications is an iterative process but previously it could be quite cumbersome to do so effectively when editing the application in an editor. To improve this we have added a --autoreload flag to the panel serve CLI command. When autoreload is set the source files in the script are watched and the browser view is reloaded when a file is changed.\n\n&lt;video src=\"autoreload.mp4\" controls width=800&gt;&lt;/video&gt;\n\nThe --autoreload option even handles error conditions gracefully. If the application script cannot be executed the error is displayed in place of the application:\n\n&lt;img src=\"autoreload_error.png\" width=800&gt;&lt;/video&gt;"
  },
  {
    "objectID": "posts/panel_release_0.11/index.html#loading-parameter",
    "href": "posts/panel_release_0.11/index.html#loading-parameter",
    "title": "Panel 0.11.0 Release",
    "section": "Loading parameter",
    "text": "Loading parameter\nTo provide users of an application or dashboard with a good user experience and a feeling of responsiveness loading spinners and indicators are very important. Therefore this release has added a loading parameter to all Panel components which overlays the component with a spinner. Panel provides a selection of spinner types to choose from, which can be controlled globally using the config object:\n\npn.config.loading_spinner: The style of the global loading indicator, e.g. ‘arcs’, ‘bars’, ‘dots’, ‘petals’.\npn.config.loading_color: The color of the global loading indicator as a hex color, e.g. #6a6a6a.\n\n\npn.Row(*(pn.pane.SVG(open(pn.io.resources.ASSETS_DIR / f'{spinner}_spinner.svg').read().format(color='green'), height=200, width=200)\n         for spinner in pn.config.param.loading_spinner.objects))\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nThe loading parameter can be controlled from Python to indicate a component is loading but can also be used directly from Javascript. Below you can see a demo of the default loading indicator and toggle it on and off using the jslinked checkbox:\n\nhtml = pn.pane.HTML(width=200, height=200, background='black', loading=True)\n\npn.Column(\n    html.controls(['loading'], jslink=True)[1],\n    html\n)"
  },
  {
    "objectID": "posts/panel_release_0.11/index.html#templates",
    "href": "posts/panel_release_0.11/index.html#templates",
    "title": "Panel 0.11.0 Release",
    "section": "Templates",
    "text": "Templates\nIn the 0.10 release Panel introduced the concept of easily reusable templates and shipped a number of default templates. In this release the templates were further polished to achieve a more consistent look and feel when using the DarkTheme. Additionally we made it possible to add custom CSS and JS files directly on a template using the Template.config object, making it possible to add different resources to different routes in an application.\nFinally we added a new Fast UI based templates to join the lineup of templates provided by Panel.\n\nFastListTemplate: Builds on the Fast UI framework, making it easy to build polished looking applications and dashboards.\n\n\n\n\n\nFastGridTemplate: Builds on the Fast UI framework and react grid layouts, making it easy to build responsive, resizable and draggable grid layouts."
  },
  {
    "objectID": "posts/panel_release_0.11/index.html#components",
    "href": "posts/panel_release_0.11/index.html#components",
    "title": "Panel 0.11.0 Release",
    "section": "Components",
    "text": "Components\nThis release adds a number of new components to include in your applications and dashboards.\n\nTabulator widget\nPowerful data tables or grids are an essential part of many data-centric applications and this release includes the feature-rich Tabulator component. This new table or data-grid is built on the Tabulator.js library, which is highly extensible, performant and feature rich.\n\ndf = pd.DataFrame(np.random.randn(1000, 4), columns=list('ABCD'))\n\ntabulator = pn.widgets.Tabulator(\n    df, pagination='remote',\n    frozen_columns=['index'],\n    selectable='checkbox',\n    page_size=10\n)\n\n# Pandas styling API\ntabulator.style.applymap(lambda v: 'color: green' if v &gt; 0 else 'color: red')\n\ntabulator\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nNote that the pagination requires a live server to dynamically fetch new data.\nSome highlights of include:\n\nRich formatters and editors\nIntelligent column layout and resizing\nPandas .style API to achieve custom look and feel\nRemote pagination support to handle very large tables\nWide range of themes to choose from\nSupport for freezing and grouping columns and rows\nPowerful filtering API\nAbility to download table data directly in Javascript\nEfficient streaming and patching of data\n\nTo see more detail find the documentation in the Panel reference guide.\n\n\nFINOS Perspective\nPerspective is an interactive visualization component for large, real-time datasets. Originally developed for J.P. Morgan’s trading business, Perspective makes it simple to build real-time & user configurable analytics entirely in the browser. The Perspective component\n\nperspective = pn.pane.Perspective(\n    df.cumsum(), plugin='d3_y_line', columns=['A', 'B', 'C', 'D'], theme='material-dark',\n    sizing_mode='stretch_width', height=500\n)\n\nperspective\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nSee more details in the Perspective reference gallery entry.\n\n\nIDOM support\nIDOM is a Python library for defining and controlling interactive webpages. It allows us to write interactive HTML components directly from Python and embed those in a Panel application, e.g. below we define a Slideshow component consisting of an img element with a callback which advances the image index on click.\n\n@idom.component\ndef Slideshow():\n    index, set_index = idom.hooks.use_state(0)\n\n    def next_image(event):\n        set_index(index + 1)\n\n    return idom.html.img(\n        {\n            \"src\": f\"https://picsum.photos/800/300?image={index}\",\n            \"style\": {\"cursor\": \"pointer\"},\n            \"onClick\": next_image,\n        }\n    )\n\npn.pane.IDOM(Slideshow, height=300);\n\n\n&lt;img src=\"idom.gif\" width=800&gt;&lt;/video&gt;\n\nSee more details in the IDOM reference gallery entry.\n\n\nTrend indicator\nA common need for dashboards is communicating key performance indicator (KPIs) in a visually clean form. This release adds the Trend indicator to the existing lineup of indicators. The Trend indicator shows a number, a change indicator and a plot and responsively resizes to fill the available space. It also provides methods to stream new data to the view:\n\ntrend = pn.indicators.Trend(\n    title=\"Panel Users\",\n    plot_type='line',\n    data={\"x\": [0, 1, 2, 3, 4, 5], \"y\": [300, 3800, 3700, 3800, 3900, 4000]},\n    height=300,\n    width=300\n)\n\ncontrols = trend.controls(jslink=True).clone(scroll=True, height=355)\n\npn.Row(controls, trend)\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nThe ability to stream allows us to performantly update many views at once:\n\n&lt;img src=\"trend.gif\" width=640&gt;&lt;/video&gt;\n\n\n\nTextToSpeech and SpeechToText\nThe TextToSpeech and SpeechToText widgets as their names suggests turn text into speech and speech into text using the browser APIs.\n\n&lt;video src=\"text_to_speech.mp4\" controls width=400&gt;&lt;/video&gt;\n&lt;video src=\"speech_to_text.mp4\" controls width=400&gt;&lt;/video&gt;"
  },
  {
    "objectID": "posts/panel_release_0.11/index.html#roadmap",
    "href": "posts/panel_release_0.11/index.html#roadmap",
    "title": "Panel 0.11.0 Release",
    "section": "Roadmap",
    "text": "Roadmap\nThis release has included a ton of great features but many of the roadmap items from the previous release are still open.\n\nCustom components\nWith the IDOM pane users can now build custom HTML components however in the future we also want to provide expert users with the power to develop their own HTML objects (including custom WebComponents), using native Panel implementation.\n\n\nTemplated layouts\nComplementing the ability to define individual custom components, we want to allow users to declare custom layouts by writing small HTML template strings the components will be inserted into. This will make it possible to leverage custom CSS or JS frameworks, e.g. to build custom types of responsive grids that can be used just like the current Panel layouts (Row, Column, etc.).\n\n\nResponsive grids\nIn addition to allowing users to build custom layouts using their favorite CSS/JS frameworks, we also want to ship a well-suported responsive grid layout that reflows components on the page based on the size of the browser tab. Reflowing will make it much easier to provide a great experience on mobile devices.\n\n\nBetter debugging and profiling\nWe also want to make the process of desiging, building, debugging, and optimizing apps easier. We plan to develop new tools to visualize Panel and Param callback and dependency graphs, to help developers understand how data and events propagate through their panels. To help them identify performance bottlenecks, these graphs will be annotated with timing information so that the slow steps can easily be identified.\n\n\nDocumentation overhaul\nAs we approach a Panel 1.0 release we want to overhaul the documentation so it becomes much easier to find the information you are looking for.\n\n\nHelp us!\nPanel is an open-source project and we are always looking for new contributors. Join us the discussion on the Discourse and we would be very excited to get you started contributing! Also please get in touch with us if you work at an organization that would like to support future Panel development, fund new Panel features, or set up a support contract.\n\n\nSponsors\nMany thanks to our existing sponsors:\n\n\n\n\n\n  \n\n\n  \n\n\n\n\n&lt;/div&gt;"
  },
  {
    "objectID": "posts/panel_release_0.14/index.html",
    "href": "posts/panel_release_0.14/index.html",
    "title": "",
    "section": "",
    "text": "TODO\n\n\n\n Back to top"
  }
]